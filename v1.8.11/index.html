<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CamiXon.jl</title><meta name="title" content="Home · CamiXon.jl"/><meta property="og:title" content="Home · CamiXon.jl"/><meta property="twitter:title" content="Home · CamiXon.jl"/><meta name="description" content="Documentation for CamiXon.jl."/><meta property="og:description" content="Documentation for CamiXon.jl."/><meta property="twitter:description" content="Documentation for CamiXon.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CamiXon.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Table-of-contents"><span>Table of contents</span></a></li><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Codata"><span>Codata</span></a></li><li><a class="tocitem" href="#Atomic-properties"><span>Atomic properties</span></a></li><li><a class="tocitem" href="#Thermodynamic-properties"><span>Thermodynamic properties</span></a></li><li><a class="tocitem" href="#Angular-momentum"><span>Angular momentum</span></a></li><li><a class="tocitem" href="#Grid"><span>Grid</span></a></li><li><a class="tocitem" href="#Adams-Moulton-integration"><span>Adams-Moulton integration</span></a></li><li><a class="tocitem" href="#Coulomb-integrals"><span>Coulomb integrals</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Julia-tools"><span>Julia tools</span></a></li><li><a class="tocitem" href="#Finite-difference-methods"><span>Finite-difference methods</span></a></li><li><a class="tocitem" href="#Strings"><span>Strings</span></a></li><li><a class="tocitem" href="#Dicts"><span>Dicts</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://walra356.github.io/CamiXon.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="github.com/walra356/CamiXon.jl.git" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CamiXon.jl"><a class="docs-heading-anchor" href="#CamiXon.jl">CamiXon.jl</a><a id="CamiXon.jl-1"></a><a class="docs-heading-anchor-permalink" href="#CamiXon.jl" title="Permalink"></a></h1><p>A package for image analysis of backscattered light</p><hr/><h2 id="Table-of-contents"><a class="docs-heading-anchor" href="#Table-of-contents">Table of contents</a><a id="Table-of-contents-1"></a><a class="docs-heading-anchor-permalink" href="#Table-of-contents" title="Permalink"></a></h2><ul><li><a href="#CamiXon.jl">CamiXon.jl</a></li><li class="no-marker"><ul><li><a href="#Table-of-contents">Table of contents</a></li><li><a href="#Introduction">Introduction</a></li><li><a href="#Codata">Codata</a></li><li><a href="#Atomic-properties">Atomic properties</a></li><li><a href="#Thermodynamic-properties">Thermodynamic properties</a></li><li><a href="#Angular-momentum">Angular momentum</a></li><li><a href="#Grid">Grid</a></li><li><a href="#Adams-Moulton-integration">Adams-Moulton integration</a></li><li><a href="#Coulomb-integrals">Coulomb integrals</a></li><li><a href="#Plotting">Plotting</a></li><li><a href="#Julia-tools">Julia tools</a></li><li><a href="#Finite-difference-methods">Finite-difference methods</a></li><li><a href="#Strings">Strings</a></li><li><a href="#Dicts">Dicts</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>CamiXon is a package for the numerical solution of the radial Schrödinger equation allowing for screening.</p><p>In this package the solution is obtained for a single electron, acting as a <em>spectator</em> in the central field of the atomic nucleus screened by &#39;the other&#39; electrons (the <em>screening</em> electrons).</p><p>The starting point is the 1D Schrödinger equation,</p><p class="math-container">\[\tilde{χ}_{l}^{′′}+2[Z_{\mathrm{eff}}(ρ)/ρ-l(l+1)/2ρ^{2}+ε_{l}]\tilde{χ}_{l}=0,\]</p><p>where <span>$\tilde{\chi}_{l}(\rho)=\rho\tilde{R}_{l}(\rho)$</span> is the reduced radial wavefunction and <span>$ε_{l}=-κ _{l}^{2}$</span> is the corresponding binding energy in Hartree atomic units (a.u.). As compared to the hydrogenic case, the atomic number <span>$Z$</span> has been replaced by <span>$Z_{\mathrm{eff}}(ρ)$</span>, the <em>effective nuclear charge</em> at radial distance <span>$ρ$</span> from the atomic center (in a.u.). In other words, the energy of the electron in the Coulomb field of the nucleus is replaced by an effective, central field potential of the form</p><p class="math-container">\[U_{\mathrm{CF}}(ρ)=-Z_{\mathrm{eff}}(ρ)/ρ=-Z/ρ+U_{\mathrm{scr}}(ρ),\]</p><p>consisting of the bare Coulomb contribution, <span>$-Z/ρ$</span>, and the screening field <span>$U_{\mathrm{scr}}(ρ)$</span>, subject to the boundary conditions <span>$U_{\mathrm{scr}}(0)=Z$</span> and <span>$\mathrm{lim}_{ρ→\infty}U_{\mathrm{scr}}(ρ)=Z_{c}/ρ$</span>. Here <span>$Z_{c}$</span> is the Rydberg charge; i.e. the effective nuclear charge for a spectator electron in the far field <span>$(ρ→\infty)$</span>. Within these assumptions we can optimize <span>$U_{\mathrm{scr}}(ρ)$</span>, while preserving the bare Coulomb field close to the nucleus as well as the Rydberg potential in the far field. The price we pay is that the radial Schrödinger equation has to be solved numerically by radial integration. Our strategy is to use both <em>inward</em> and <em>outward</em> integration and match the two branches by <em>equating the two solutions</em> for the <em>wavefunction</em>, <span>$χ(ρ)$</span>, and its <em>derivative</em>, <span>$χ^′(ρ)$</span>, at a point near the classical turning point of the radial motion of the electron. The basics of the solution can be found in the book <em>Atomic Structure Theory</em> by Walter R. Johnson.</p><h4 id="Illustration:-the-hydrogen-3d-orbital"><a class="docs-heading-anchor" href="#Illustration:-the-hydrogen-3d-orbital">Illustration: the hydrogen 3d orbital</a><a id="Illustration:-the-hydrogen-3d-orbital-1"></a><a class="docs-heading-anchor-permalink" href="#Illustration:-the-hydrogen-3d-orbital" title="Permalink"></a></h4><p>Shown below are the reduced radial wavefunction <span>$(χ)$</span> and its derivative <span>$(χ^′)$</span> in the near field (left), the far field (right), and in the region near the classical turning point (center). </p><p><img src="assets/H1_3d.png" alt="Image"/></p><h2 id="Codata"><a class="docs-heading-anchor" href="#Codata">Codata</a><a id="Codata-1"></a><a class="docs-heading-anchor-permalink" href="#Codata" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.Codata" href="#CamiXon.Codata"><code>CamiXon.Codata</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Codata</code></pre><p>Object to hold the natural constants from CODATA. It is best created with the function <a href="#CamiXon.castCodata-Tuple{Int64}"><code>castCodata</code></a></p><p>The fields are:</p><ul><li><code>.∆νCs</code>: Cs hyperfine transition frequency (<code>::Value</code>)</li><li><code>.c</code>: speed of light in vacuum (<code>::Value</code>)</li><li><code>.h</code>: Planck constant (<code>::Value</code>)</li><li><code>.ħ</code>: Planck constant - reduced (<code>::Value</code>)</li><li><code>.e</code>: elementary charge (<code>::Value</code>)</li><li><code>.kB</code>: Boltzmann constant (<code>::Value</code>)</li><li><code>.NA</code>: Avogadro constant (<code>::Value</code>)</li><li><code>.Kcd</code>: Luminous efficacy (<code>::Value</code>)</li><li><code>.me</code>: electron rest mass (<code>::Value</code>)</li><li><code>.R∞</code>: Rydberg constant (<code>::Value</code>)</li><li><code>.Ry</code>: Rydberg frequency (<code>::Value</code>)</li><li><code>.Eh</code>: Hartree a.u. (<code>::Value</code>)</li><li><code>.α</code>: fine-structure constant (<code>::Value</code>)</li><li><code>.μ0</code>: magnetic permitivity of vacuum (<code>::Value</code>)</li><li><code>.ε0</code>: electric permitivity of vacuum (<code>::Value</code>)</li><li><code>.KJ</code>: Josephson constant (<code>::Value</code>)</li><li><code>.RK</code>: Von Klitzing constant (<code>::Value</code>)</li><li><code>.R</code>: Molar gas constant (<code>::Value</code>)</li><li><code>.u</code>: unified atomic mass unit (<code>::Value</code>)</li><li><code>.matE</code>: unit conversion matrix (Matrix{Float64})</li></ul><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">codata = castCodata(2018)
codata.μ0
  Value(1.2566370621250601e-6, &quot;N A⁻²&quot;)

codata.μ0.val
  1.2566370621250601e-6</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.Value" href="#CamiXon.Value"><code>CamiXon.Value</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Value(val::Real, unit::String)</code></pre><p>Object to hold a real numerical value together with a unit specifier.</p><p>The fields are:</p><ul><li><code>.val</code>: numerical value (<code>::Real</code>)</li><li><code>.unit</code>: unit specifier (<code>::String</code>)</li></ul><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">f = Value(1,&quot;Hz&quot;)
  Value(1, &quot;Hz&quot;)

f.val
  1

f.unit
  &quot;Hz&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.strValue-Tuple{Value}" href="#CamiXon.strValue-Tuple{Value}"><code>CamiXon.strValue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strValue(f::Value)</code></pre><p>String expression for a <a href="#CamiXon.Value"><code>Value</code></a> object in <code>:compact =&gt; true</code> representation</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">f = Value(1,&quot;Hz&quot;)
strValue(f)
  &quot;1 Hz&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.NamedValue" href="#CamiXon.NamedValue"><code>CamiXon.NamedValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NamedValue(val::Value, name::String, comment::String)</code></pre><p>Object to hold a <a href="#CamiXon.Value"><code>Value</code></a> together with its <code>symbolic name</code> and a <code>short</code> description</p><p>The fields are:</p><ul><li><code>.val</code>: Value  (<code>::Value</code>)</li><li><code>.name</code>: symbolic name (<code>::String</code>)</li><li><code>.comment</code>: description (<code>::String</code>)</li></ul><p>Named Value object The object <code>NamedValue</code> is best created using <a href="#CamiXon.castNamedValue-Tuple{Value}"><code>castNamedValue</code></a>.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">f = Value(1,&quot;Hz&quot;)
  Value(1, &quot;Hz&quot;, &quot;frequency&quot;)

f.name
  &quot;frequency&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.castNamedValue-Tuple{Value}" href="#CamiXon.castNamedValue-Tuple{Value}"><code>CamiXon.castNamedValue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">castNamedValue(val::Value; name=&quot; &quot;, comment=&quot; &quot;)</code></pre><p>Method to create a <a href="#CamiXon.NamedValue"><code>NamedValue</code></a> object</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">v = Value(1.602176634e-19, &quot;C&quot;)
nv = castNamedValue(v; name=&quot;e&quot;)
nv.name * &quot; = &quot; * strValue2(nv.val)
  &quot;e = 1.60218e-19 C&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.castCodata-Tuple{Int64}" href="#CamiXon.castCodata-Tuple{Int64}"><code>CamiXon.castCodata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">castCodata(year::Int)</code></pre><p>Method to create the <a href="#Codata"><code>Codata</code></a> object</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">codata = castCodata(2018)
strValue.([codata.∆νCs,codata.c,codata.h])
 3-element Vector{String}:
  &quot;9192631770 Hz&quot;
  &quot;299792458 m s⁻¹&quot;
  &quot;6.62607e-34 J Hz⁻¹&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.listCodata-Tuple{Codata}" href="#CamiXon.listCodata-Tuple{Codata}"><code>CamiXon.listCodata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">listCodata(codata::Codata)</code></pre><p>Method to list the fields of <a href="#Codata"><code>Codata</code></a> by their symbolic name</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; codata = castCodata(2018);

julia&gt; listCodata(codata)
∆νCs = 9192631770 Hz      - ¹³³Cs hyperfine transition frequency
   c = 299792458 m s⁻¹    - speed of light in vacuum
   h = 6.62607e-34 J Hz⁻¹ - Planck constant
   ħ = 1.05457e-34 J s    - Planck constant (reduced)
   e = 1.60218e-19 C      - elementary charge
  kB = 1.38065e-23 J K⁻¹  - Boltzmann constant
  NA = 6.02214e23 mol⁻¹   - Avogadro constant
 Kcd = 683 lm W⁻¹         - Luminous efficacy
  mₑ = 9.10938e-31 Kg     - electron rest mass
  R∞ = 1.09737e7 m⁻¹      - Rydberg constant
  Ry = 3.28984e15 Hz      - Rydberg frequency
  Eₕ = 4.35974e-18 Hartree a.u. - Hartree atomic unit
   α = 0.00729735         - fine-structure constant
  μ₀ = 1.25664e-6 N A⁻²   - magnetic permitivity of vacuum
  ε₀ = 8.85419e-12 F m⁻¹  - electric permitivity of vacuum
  KJ = 4.83598e14 Hz V⁻¹  - Josephson constant
  RK = 25812.8 Ω          - Von Klitzing constant
   R = 8.31446 J mol⁻¹K⁻¹ - Molar gas constant
   u = 1.66054e-27 kg     - unified atomic mass unit

julia&gt; codata.u.val
1.6605390666e-27  </code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.convertUnit-Tuple{Any, Any}" href="#CamiXon.convertUnit-Tuple{Any, Any}"><code>CamiXon.convertUnit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">convertUnit(val, codata; unitIn=&quot;Hartree&quot;, unitOut=&quot;xHz&quot;)</code></pre><p>Unit conversion between μHz,⋯ EHz, Hartree, Rydberg, Joule, and eV</p><p>default input: Hartree</p><p>default output: xHz ∈ {μHz, mHz, Hz, kHz, MHz, GHz, THz, PHz, EHz}</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">codata = castCodata(2018)
convertUnit(1, codata; unitIn=&quot;Hz&quot;, unitOut=&quot;Joule&quot;)
  6.62607015e-34

convertUnit(1, codata; unitIn=&quot;Hartree&quot;, unitOut=&quot;Hz&quot;)
  Value(6.57968392050182e15, &quot;Hz&quot;)

f = convertUnit(1, codata) # default input (Hartree) and output (xHz)
strf = strValue(f)
  &quot;6.57968 PHz&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.calibrationReport-Tuple{Any, Any, Codata}" href="#CamiXon.calibrationReport-Tuple{Any, Any, Codata}"><code>CamiXon.calibrationReport</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calibrationReport(E, Ecal, codata::Codata; unitIn=&quot;Hartree&quot;, msg=true)</code></pre><p>Comparison of energy E with calibration value Ecal</p><p>default input: Hartree</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">codata = castCodata(2018)
calibrationReport(1.1, 1.0, codata; unitIn=&quot;Hartree&quot;)
  calibration report (Float64):
  Ecal = 1.0 Hartree
  E = 1.1 Hartree
  absolute accuracy: ΔE = 0.1 Hartree (657.968 THz)
  relative accuracy: ΔE/E = 0.0909091</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h2 id="Atomic-properties"><a class="docs-heading-anchor" href="#Atomic-properties">Atomic properties</a><a id="Atomic-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Atomic-properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.Element" href="#CamiXon.Element"><code>CamiXon.Element</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Element(name, symbol, weight)</code></pre><p>Type with fields:</p><ul><li><code>.name</code>:  name of element (<code>::String</code>)</li><li><code>.symbol</code>:  symbol of element  (<code>::String</code>)</li><li><code>.weight</code>:  relative atomic mass - atomic weight (<code>::Float64</code>)</li></ul><p>The type <code>Element</code> is best created with the function <a href="#CamiXon.castElement-Tuple{}"><code>castElement</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.Isotope" href="#CamiXon.Isotope"><code>CamiXon.Isotope</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Isotope(symbol, name, Z, A, N, R, M, I, π, T½, mdm, eqm, ra)</code></pre><p>Type with fields:</p><ul><li><code>.symbol</code>: symbol (<code>::String</code>)</li><li><code>.name</code>: name (<code>::String</code>)</li><li><code>.Z</code>:  atomic number (<code>::Int</code>)</li><li><code>.A</code>:  atomic mass number in amu (<code>::Int</code>)</li><li><code>.N</code>:  neutron number (<code>::Int</code>)</li><li><code>.R</code>:  rms charge radius in Fermi (<code>::Float64</code>)</li><li><code>.M</code>:  <em>atomic</em> mass in amu (<code>::Float64</code>)</li><li><code>.I</code>:  nuclear spin in units of ħ  (<code>::Rational{Int}</code>)</li><li><code>.π</code>:  parity of nuclear state (<code>::Int</code>)</li><li><code>.T½</code>:  lifetime in years (<code>::Float64</code>)</li><li><code>.mdm</code>: nuclear magnetic dipole moment (<code>::Float64</code>)</li><li><code>.eqm</code>: nuclear electric quadrupole moment (<code>::Float64</code>)</li><li><code>.ra</code>:  relative abundance in % (<code>::Float64</code>)</li></ul><p>The type <code>Isotope</code> is best created with the function <a href="#CamiXon.castIsotope-Tuple{}"><code>castIsotope</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.Atom" href="#CamiXon.Atom"><code>CamiXon.Atom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Atom(Z, A, Q, Zc, element, isotope)</code></pre><p>Type with fields:</p><ul><li><code>.Z</code>:  atomic number (<code>::Int</code>)</li><li><code>.A</code>:  atomic mass number in amu (<code>::Int</code>)</li><li><code>.Q</code>:  ionic charge in a.u. (<code>::Int</code>)</li><li><code>.Zc</code>:  Rydberg charge in a.u. (<code>::Int</code>)</li><li><code>.element</code>:  (<code>::Element</code>)</li><li><code>.isotope</code>:  (<code>::Isotope</code>)</li></ul><p>The type <code>Atom</code> is best created with the function <a href="#CamiXon.castAtom-Tuple{}"><code>castAtom</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.Orbit" href="#CamiXon.Orbit"><code>CamiXon.Orbit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Orbit(name, n, n′, ℓ, mℓ)</code></pre><p>Type for specification of <em>atomic orbitals</em> with fields:</p><ul><li><code>.name</code>: name</li><li><code>.n</code>:  principal quantum number</li><li><code>.n′</code>:  radial quantum number (number of nodes in radial wavefunction)</li><li><code>.ℓ</code>:  orbital angular momentum valence electron</li><li><code>.mℓ</code>:  orbital angular momentum projection valence electron</li></ul><p>The type <code>Orbit</code> is best created with the function <code>castOrbit</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.Spinorbit" href="#CamiXon.Spinorbit"><code>CamiXon.Spinorbit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Spinorbit</code></pre><p>Type for specification of <em>atomic Spinorbitals</em> with fields:</p><ul><li><code>.name</code>: spinorbital name (string)</li><li><code>.orbit</code>: orbital object (Orbit)</li><li><code>.ms</code>: spin magnetic quantum number (Rational{Int})</li></ul><p>The type <code>Spinorbit</code> is best created with the function <code>castSpinorbit</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.Term" href="#CamiXon.Term"><code>CamiXon.Term</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Term(name::String, n::Int, ℓ::Int, S::Real, L::Int, J::Real)</code></pre><p>Type for specification of atomic <em>fine-structure Terms</em> with fields:</p><ul><li><code>name</code>: name</li><li><code>.n</code>:  principal quantum number</li><li><code>.n′</code>:  radial quantum number (number of nodes in wavefunction)</li><li><code>.ℓ</code>:  orbital angular momentum valence electron</li><li><code>.S</code>:  total electron spin in units of ħ</li><li><code>.L</code>:  total orbital angular momentum in units of ħ</li><li><code>.J</code>:  total electronic angular momentum in units of ħ</li></ul><p>The type <code>Term</code> is best created with the function <code>createTerm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.listElement-Tuple{Int64}" href="#CamiXon.listElement-Tuple{Int64}"><code>CamiXon.listElement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">listElement(Z::Int[; fmt=Object])
listElement(elt::String[; fmt=Object])</code></pre><p>Properties of element with atomic number <code>Z</code>.</p><p>Output options: <code>fmt</code> =  <code>Object</code> (default), <code>String</code>, <code>Info</code>.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">listElement(&quot;H&quot;) == listElement(1)
  true

listElement(1; fmt=Info)
  Element: hydrogen
    symbol: H
    atomic number: Z = 1
    atomic weight (relative atomic mass): 1.008</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.listElements-Tuple{Int64, Int64}" href="#CamiXon.listElements-Tuple{Int64, Int64}"><code>CamiXon.listElements</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">listElements(Z1::Int, Z2::Int[; fmt=Object])
listElements(itrZ::UnitRange{Int}; fmt=Object)</code></pre><p>Properties of elements with atomic number in the range <code>Z1:Z2</code>.</p><p>Output options: <code>fmt</code> =  <code>Object</code> (default), <code>String</code>, <code>Info</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">listElements(1,3) == listElements(1:3)
  true

listElements(1:3; fmt=Info)
  Element: hydrogen
    symbol: H
    atomic number: Z = 1
    atomic weight (relative atomic mass): 1.008
  Element: helium
    symbol: He
    atomic number: Z = 2
    atomic weight (relative atomic mass): 4.0026
  Element: lithium
    symbol: Li
    atomic number: Z = 3
    atomic weight (relative atomic mass): 6.94</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.castElement-Tuple{}" href="#CamiXon.castElement-Tuple{}"><code>CamiXon.castElement</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">castElement(;Z=1, msg=true)
castElement(elt::String; msg=true)</code></pre><p>Create Atom with fields</p><ul><li><code>.name</code>:  name of element</li><li><code>.symbol</code>:  symbol of element</li><li><code>.weight</code>:  relative atomic mass (atomic weight)</li></ul><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">castElement(&quot;Rb&quot;; msg=false) == castElement(Z=37, msg=false)
  true

element = castElement(;Z=1, msg=true)
element
  Element created: H, hydrogen, Z=1, weight=1.008

  Element(&quot;hydrogen&quot;, &quot;H&quot;, 1.008)</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.listIsotope-Tuple{Int64, Int64}" href="#CamiXon.listIsotope-Tuple{Int64, Int64}"><code>CamiXon.listIsotope</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">listIsotope(Z::Int, A::Int; fmt=Object)</code></pre><p>Properties of isotopes with atomic number <code>Z</code> and atomic mass number <code>A</code>.</p><p>Output options: <code>fmt</code> =  <code>Object</code> (default), <code>String</code>, <code>Latex</code>, <code>Info</code>.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">listIsotope(1,3; fmt=Info)
  Isotope: tritium-3
    symbol: ³T
    element: tritium
    atomic number: Z = 1
    atomic mass number: A = 3
    neutron number: N = 2
    rms nuclear charge radius: R = 1.7591 fm
    atomic mass: M = 3.016049281 amu
    nuclear spin: I = 1/2 ħ
    parity of nuclear state: π = even
    nuclear magnetic dipole moment: μI = 2.97896246μN
    nuclear electric quadrupole moment: Q = 0.0barn
    relative abundance: RA = trace
    lifetime: 12.33 years</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.listIsotopes-Tuple{Int64, Int64}" href="#CamiXon.listIsotopes-Tuple{Int64, Int64}"><code>CamiXon.listIsotopes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">listIsotopes(Z1::Int, Z2::Int; fmt=Object)</code></pre><p>All isotopes with atomic number from <code>Z1</code> to <code>Z2</code>.</p><p>Output options: <code>Object</code> (default), <code>String</code>, <code>Latex</code>, <code>Info</code>.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">listIsotopes(1,3) == listIsotopes(1:3)
 true

listIsotopes(1:1; fmt=Info)
 3-element Vector{Any}:
  Isotope(&quot;¹H&quot;, &quot;hydrogen&quot;, 1, 1, 0, 0.8783, 1.007825032, 1//2, 1, 1.0e100, 2.792847351, 0.0, 99.9855)
  Isotope(&quot;²D&quot;, &quot;deuterium&quot;, 1, 2, 1, 2.1421, 2.014101778, 1, 1, 1.0e100, 0.857438231, 0.0028578, 0.0145)
  Isotope(&quot;³T&quot;, &quot;tritium&quot;, 1, 3, 2, 1.7591, 3.016049281, 1//2, 1, 12.33, 2.97896246, 0.0, nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.latexIsotopeTable-Tuple{Int64, Int64}" href="#CamiXon.latexIsotopeTable-Tuple{Int64, Int64}"><code>CamiXon.latexIsotopeTable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">latexIsotopeTable(Z1::Int, Z2::Int; continuation=false)
latexIsotopeTable(itrZ::UnitRange; continuation=false)</code></pre><p>Isotope table for all isotopes with atomic number from <code>Z1</code> to <code>Z2</code>.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">o = latexIsotopeTable(1:3);
println(o)
  \setlength{\tabcolsep}{3pt}
  \renewcommand{\arraystretch}{1.2}
  \begin{table}[H]
    \centering
    \caption{\label{table:Isotopes-a-1}Properties of selected atomic isotopes. The Table is based on three databases: (a) AME2020 (atomic mass evaluation); (b) IAEA-INDC(NDS)-794 (magnetic dipole moments); (c) IAEA-INDC(NDS)-833 (electric quadrupole moments).}
    \begin{tabular}{r|lr|rrrr|r|r|r|r}
      \multicolumn{12}{r}\vspace{-18pt}\\
      \hline
      \hline
      $Z$ &amp; element &amp; symbol &amp; $A$ &amp; $N$ &amp; radius &amp; atomic mass &amp; $I\,^\pi$ &amp; $\mu_I $ &amp; $Q$ &amp; $RA$\\&amp;  &amp;  &amp;  &amp;  &amp; (fm) &amp; $(m_u)$ &amp; $(\hbar)\ \ $ &amp; $(\mu_N)$ &amp; (barn) &amp; (\%)\\\hline
      1 &amp; hydrogen &amp; $^{1}$H &amp; 1\, &amp; 0 &amp; 0.8783 &amp; 1.007825032 &amp; 1/2$^+$ &amp; 2.792847351 &amp; 0.0 &amp; 99.9855 \\
        &amp;  &amp; $^{2}$H &amp; 2\, &amp; 1 &amp; 2.1421 &amp; 2.014101778 &amp; 1//1$^+$ &amp; 0.857438231 &amp; 0.0028578 &amp; 0.0145 \\
        &amp;  &amp; $^{3}$H &amp; 3$*\!\!$ &amp; 2 &amp; 1.7591 &amp; 3.016049281 &amp; 1/2$^+$ &amp; 2.97896246 &amp; 0.0 &amp; trace \\
      \hline
      2 &amp; helium &amp; $^{3}$He &amp; 3\, &amp; 1 &amp; 1.9661 &amp; 3.016029322 &amp; 1/2$^+$ &amp; -2.12762531 &amp; 0.0 &amp; 0.0002 \\
        &amp;  &amp; $^{4}$He &amp; 4\, &amp; 2 &amp; 1.6755 &amp; 4.002603254 &amp; 0//1$^+$ &amp; 0.0 &amp; 0.0 &amp; 99.9998\% \\
      \hline
      3 &amp; lithium &amp; $^{6}$Li &amp; 6\, &amp; 3 &amp; 2.589 &amp; 6.015122887 &amp; 1//1$^+$ &amp; 0.822043 &amp; -0.000806 &amp; 4.85 \\
        &amp;  &amp; $^{7}$Li &amp; 7\, &amp; 4 &amp; 2.444 &amp; 7.016003434 &amp; 3/2$^-$ &amp; 3.256407 &amp; -0.04 &amp; 95.15 \\
      \hline
      \multicolumn{12}{l}{*radioactive }\\
    \end{tabular}
  \end{table}</code></pre><p>The typeset result is shown in the figule below.</p><p><img src="assets/latexIsotopeTable.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.castIsotope-Tuple{}" href="#CamiXon.castIsotope-Tuple{}"><code>CamiXon.castIsotope</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">castIsotope(;Z=1, A=1, msg=false)
castIsotope(elt::String; A=1, msg=false)</code></pre><p>Create Isotope with fields</p><ul><li><code>.symbol</code>: symbol (<code>::String</code>)</li><li><code>.name</code>: symbol (<code>::String</code>)</li><li><code>.Z</code>:  atomic number (<code>::Int</code>)</li><li><code>.A</code>:  atomic mass number in amu (<code>::Int</code>)</li><li><code>.N</code>:  neutron number (<code>::Int</code>)</li><li><code>.R</code>:  rms charge radius in Fermi (<code>::Float64</code>)</li><li><code>.M</code>:  atomic mass in amu (<code>::Float64</code>)</li><li><code>.I</code>:  nuclear spin in units of ħ (<code>::Rational{Int}</code>)</li><li><code>.π</code>:  parity of nuclear state (<code>::Int</code>)</li><li><code>.ra</code>:  relative abundance in % (<code>::Float64</code>)</li><li><code>.mdm</code>: nuclear magnetic dipole moment (<code>::Float64</code>)</li><li><code>.eqm</code>: nuclear electric quadrupole moment (<code>::Float64</code>)</li><li><code>.T½</code>:  lifetime in years (<code>::Float64</code>)</li></ul><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">castIsotope(&quot;Rb&quot;; A=87) == castIsotope(Z=37, A=87)
  true

isotope = castIsotope(Z=1, A=3)
  Isotope(&quot;³T&quot;, &quot;tritium&quot;, 1, 3, 2, 1.7591, 3.016049281, 1//2, 1, 12.33, 2.97896246, 0, nothing)

isotope.T½
  12.33

castIsotope(Z=1, A=3, msg=true);
  Isotope created: tritium-3
      symbol: ³T
      element: tritium
      atomic number: Z = 1
      atomic mass number: A = 3
      neutron number: N = 2
      rms nuclear charge radius: R = 1.7591 fm
      atomic mass: M = 3.016049281 amu
      nuclear spin: I = 1/2 ħ
      parity of nuclear state: π = ⁺
      nuclear magnetic dipole moment: μI = 2.97896246μN
      nuclear electric quadrupole moment: Q = 0.0barn
      relative abundance: RA = trace
      lifetime: 12.33 years</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.listAtom-Tuple{Int64, Int64, Int64}" href="#CamiXon.listAtom-Tuple{Int64, Int64, Int64}"><code>CamiXon.listAtom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">listAtom(Z::Int, A::Int, Q::Int[; fmt=Object])</code></pre><p>Properties of atom with atomic number <code>Z</code>, atomic mass number <code>A</code>, ionic charge <code>Q</code>.</p><p>Output options: <code>fmt</code> =  <code>Object</code> (default), <code>String</code>, <code>Info</code>.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">listAtom(&quot;H&quot;, 3, 0) == listAtom(1, 3, 0)
  true

listAtom(1, 3, 0; fmt=Info)
Element: hydrogen
    symbol: H
    element: tritium
    atomic number: Z = 1
    atomic weight (relative atomic mass): 1.008</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.listAtoms-Tuple{Int64, Int64, Int64}" href="#CamiXon.listAtoms-Tuple{Int64, Int64, Int64}"><code>CamiXon.listAtoms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">listAtoms(Z1::Int, Z2::Int, Q::Int[; fmt=Object])</code></pre><p>Properties of atoms with atomic number in the range <code>Z1:Z3</code> and ionic charge <code>Q</code>.</p><p>Output options: <code>fmt</code> =  <code>Object</code> (default), <code>String</code>, <code>Info</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">listAtoms(1,3,0) == listAtoms(1:3,0)
  true

listAtoms(1:1, 0; fmt=Info);
  Atom: hydrogen, neutral atom
    symbol: ¹H
    atomic charge: Z = 1
    Rydberg charge: Zc = 1
  Atom: deuterium, neutral atom
    symbol: ²D
    atomic charge: Z = 1
    Rydberg charge: Zc = 1
  Atom: tritium, neutral atom
    symbol: ³T
    atomic charge: Z = 1
    Rydberg charge: Zc = 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.castAtom-Tuple{}" href="#CamiXon.castAtom-Tuple{}"><code>CamiXon.castAtom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">castAtom(;Z=1, A=1, Q=0, msg=false)
castAtom(elt::String; A=1, Q=0, msg=false)</code></pre><p>Create Atom with fields:</p><ul><li><code>.Z</code>:  atomic number (<code>::Int</code>)</li><li><code>.A</code>:  atomic mass number in amu (<code>::Int</code>)</li><li><code>.Q</code>:  ionic charge in a.u. (<code>::Int</code>)</li><li><code>.Zc</code>:  Rydberg charge in a.u. (<code>::Int</code>)</li><li><code>.element</code>:  (<code>::Element</code>)</li><li><code>.isotope</code>:  (<code>::Isotope</code>)</li></ul><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">castAtom(&quot;Rb&quot;; A=87, Q=0) == castAtom(Z=37, A=87, Q=0)
  true

castAtom(Z=1, A=3, Q=0)
  Atom(1, 3, 0, 1, Element(&quot;hydrogen&quot;, &quot;H&quot;, 1.008), Isotope(&quot;³T&quot;, &quot;tritium&quot;,
  1, 3, 2, 1.7591, 3.016049281, 1//2, 1, 12.33, 2.97896246, 0.0, nothing))

atom = castAtom(Z=1, A=3, Q=0, msg=true);
  Element created: H, hydrogen, Z=1, weight=1.008
  Isotope created: ³T, tritium, Z=1, A=3, N=2, R=1.7591, M=3.016049281, I=1/2⁺, μI=2.97896246, Q=0.0, RA=trace, (radioactive)
  Atom created: tritium, neutral atom, ³T, Z=1, A=3, Q=0, Zc=1

atom
  Atom(1, 3, 0, 1, Element(&quot;hydrogen&quot;, &quot;H&quot;, 1.008), Isotope(&quot;³T&quot;, &quot;tritium&quot;,
  1, 3, 2, 1.7591, 3.016049281, 1//2, 1, 12.33, 2.97896246, 0.0, nothing))

atom.isotope.T½
  12.33</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.castOrbit-Tuple{}" href="#CamiXon.castOrbit-Tuple{}"><code>CamiXon.castOrbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">castOrbit(;n=1, ℓ=0, mℓ=0, msg=true)</code></pre><p>Create <code>Orbit</code> with fields:</p><ul><li><code>.name</code>: name</li><li><code>.n</code>:  principal quantum number</li><li><code>.n′</code>:  radial quantum number (number of nodes in radial wavefunction)</li><li><code>.ℓ</code>:  orbital angular momentum valence electron</li><li><code>.mℓ</code>:  orbital angular momentum projection valence electron</li></ul><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">castOrbit(n=1, ℓ=0)
 Orbit created: 1s (n = 1, n′ = 0, ℓ = 0)
 Orbit(&quot;1s&quot;, 1, 0, 0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.castSpinorbit-Tuple{}" href="#CamiXon.castSpinorbit-Tuple{}"><code>CamiXon.castSpinorbit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">castSpinorbit(;n=1, ℓ=0, mℓ=0, up=true, msg=true)</code></pre><p>Create <code>Spinorbit</code> with fields:</p><ul><li><code>.name</code>: spinorbital name (string)</li><li><code>.orbit</code>: orbital object (Orbit)</li><li><code>.ms</code>: spin magnetic quantum number (Rational{Int})</li></ul><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; castSpinorbit(n=1, ℓ=0, msg=true)
Spinorbital: 1s↑
    principal quantum number: n = 1
    radial quantum number: n′ = 0 (number of nodes in radial wavefunction)
    orbital angular momentum of valence electron: ℓ = 0
    orbital angular momentum projection of valence electron: mℓ = 0
    spin magnetic quantum number: ms = 1/2
Spinorbit(&quot;1s↑&quot;, Orbit(&quot;1s&quot;, 1, 0, 0, 0), 1//2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.createTerm-Tuple{Int64}" href="#CamiXon.createTerm-Tuple{Int64}"><code>CamiXon.createTerm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">createTerm(n::Int; ℓ=0, S=1//2, L=0, J=1//2, msg=true)</code></pre><p>Specify Term in the <em>Term notatation</em> with fields:</p><ul><li><code>.n</code>: principal quantum number</li><li><code>.n′</code>: radial quantum number (number of nodes - autogenerated)</li><li><code>.ℓ</code>: orbital angular momentum valence electron</li><li><code>.S</code>: total electron spin</li><li><code>.L</code>: total orbital angular momentum</li><li><code>.J</code>: total electronic angular momentum</li></ul><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">term_H1I = createTerm(1; ℓ=0, S=1//2, L=0, J=1//2)
 Term created: 1s ²S₁⸝₂, n = 1, n′ = 0, ℓ = 0, S = 1//2, L = 0, J = 1//2
 Term(&quot;1s ²S₁⸝₂&quot;, 1, 0, 0, 1//2, 0, 1//2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h3 id="Hydrogen"><a class="docs-heading-anchor" href="#Hydrogen">Hydrogen</a><a id="Hydrogen-1"></a><a class="docs-heading-anchor-permalink" href="#Hydrogen" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.bohrformula-Tuple{Int64, Int64}" href="#CamiXon.bohrformula-Tuple{Int64, Int64}"><code>CamiXon.bohrformula</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bohrformula(Z::Int, n::Int)</code></pre><p>Hydrogenic energy (in Hartree a.u.) for <em>atom</em> with <em>atomic number</em> <code>Z</code> and <em>principal quantum number</em> <code>n</code>.</p><p class="math-container">\[    E_n = - \frac{Z^2}{2n^2}\]</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">Z = 2
n = 4
bohrformula(Z,n)
 -0.125</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.hydrogenic_reduced_wavefunction-Tuple{Any, Orbit, Grid}" href="#CamiXon.hydrogenic_reduced_wavefunction-Tuple{Any, Orbit, Grid}"><code>CamiXon.hydrogenic_reduced_wavefunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hydrogenic_reduced_wavefunction(Zval, orbit::Orbit, grid::Grid)</code></pre><p>Analytic expression for the hydrogenic wavefunction written in the format <span>$Z = \tilde{χ} + i \tilde{χ}^′$</span>, where <span>$\tilde{χ}_{nℓ}(ρ)$</span> is the <em>reduced</em> radial wavefunction and <span>$\tilde{χ}^′_{nℓ}(ρ)$</span> its derivative, with <span>$ρ$</span> the radial distance to the nucleus in a.u.. The expression is evaluated for a given <a href="#CamiXon.Atom"><code>Atom</code></a> in a given <a href="#CamiXon.Orbit"><code>Orbit</code></a> on a given <a href="#Grid"><code>Grid</code></a>. The argument <a href="#Def"><code>Def</code></a> completes the definition of the problem.</p><p class="math-container">\[    \tilde{\chi}_{nl}(\rho)
    =\mathcal{N}_{nl}^{-1/2}(2Z/n)^{l+3/2}\rho^{l+1}e^{-Zρ/n}
    L_{n-l-1}^{2l+1}(2Z\rho/n)\]</p><p>where <span>$L_{n-l-1}^{2l+1}(2Z\rho/n)$</span> is the generalized Laguerre polynomial <code>CamiMath.generalized_laguerreL</code> and</p><p class="math-container">\[    \mathcal{N}_{nl}
    = {\displaystyle \int\nolimits _{0}^{\infty}}x^{2l+2}e^{-x}
    \left[L_{n-l-1}^{2l+1}(x)\right]^{2}dx
    = \frac{2n\Gamma(n+l+1)}{\Gamma(n-l)}\]</p><p>is the norm of the wavefunction.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">orbit = castOrbit(n=25, ℓ=10)
grid = autoGrid(atom, orbit, Float64; Nboost=1, msg=true)
def = castDef(grid, atom, orbit, codata)
Zval = 1
Z = hydrogenic_reduced_wavefunction(Zval, orbit, grid);
    Orbital: 25n
    principal quantum number: n = 25
    radial quantum number: n′ = 14 (number of nodes in radial wavefunction)
    orbital angular momentum of valence electron: ℓ = 10
    Grid created: exponential, Float64, Rmax = 1935.0 a.u., Ntot = 1300, h = 0.00769231, r0 = 0.0878529
    Def created for hydrogen 25n on exponential grid of 1300 points

plot_wavefunction(Z, 1:grid.N, grid, def)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_wavefunction</code> is not included in the <code>CamiXon</code> package. <img src="assets/H1_25n.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.reduce_wavefunction-Union{Tuple{V}, Tuple{T}, Tuple{Array{Complex{T}, 1}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}" href="#CamiXon.reduce_wavefunction-Union{Tuple{V}, Tuple{T}, Tuple{Array{Complex{T}, 1}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.reduce_wavefunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_wavefunction(Z::Vector{Complex{T}}, grid::Grid{V}) where {T&lt;:Real, V&lt;:Real}</code></pre><p>Conversion from the <em>ordinary</em> radial wavefunction <span>$\tilde{R}_{nl}(ρ)$</span> to the <em>reduced</em> radial wavefuntion</p><p class="math-container">\[    \tilde{\chi}_{nl}(ρ) = ρ \tilde{R}_{nl}(ρ).\]</p><p>where <span>$ρ$</span> is the radial distance to the nucleus in a.u..</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">atom = castAtom(Z=1, A=1, Q=0; msg=false);
orbit = castOrbit(n=1, ℓ=0; msg=false);
grid = autoGrid(atom, orbit, Float64; Nboost=1, msg=false);
def = castDef(grid, atom, orbit, codata);

RH1s_example = [RH1s(atom.Z, grid.r[n]) for n=1:grid.N];
ZH1s_generic = hydrogenic_reduced_wavefunction(1, orbit, grid);

ZH1s_example = reduce_wavefunction(RH1s_example, grid);
RH1s_generic = restore_wavefunction(ZH1s_generic, grid);

ZH1s_example ≈ ZH1s_generic
    true

RH1s_example ≈ RH1s_generic
    true</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.restore_wavefunction-Union{Tuple{V}, Tuple{T}, Tuple{Array{Complex{T}, 1}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}" href="#CamiXon.restore_wavefunction-Union{Tuple{V}, Tuple{T}, Tuple{Array{Complex{T}, 1}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.restore_wavefunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">restore_wavefunction(Z::Vector{Complex{T}}, grid::Grid{V}) where {T&lt;:Real, V&lt;:Real}</code></pre><p>Conversion from the <em>reduced</em> radial wavefunction <span>$\tilde{\chi}_{nl}(ρ)$</span> to the <em>ordinary</em> radial wavefuntion <span>$\tilde{R}_{nl}(ρ)$</span>,</p><p class="math-container">\[    \tilde{R}_{nl}(ρ)=\tilde{\chi}_{nl}(ρ)/ρ,\]</p><p>where <span>$ρ$</span> is the radial distance to the nucleus in a.u..</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">atom = castAtom(Z=1, A=1, Q=0; msg=false);
orbit = castOrbit(n=1, ℓ=0; msg=false);
grid = autoGrid(atom, orbit, Float64; Nboost=1, msg=false);
def = castDef(grid, atom, orbit, codata);

RH1s_example = [RH1s(atom.Z, grid.r[n]) for n=1:grid.N];
ZH1s_generic = hydrogenic_reduced_wavefunction(1, orbit, grid);

ZH1s_example = reduce_wavefunction(RH1s_example);
RH1s_generic = restore_wavefunction(ZH1s_generic);

RH1s_example ≈ RH1s_generic
    true

ZH1s_example ≈ ZH1s_generic
    true

f1 = real(ZH1s_example)
f2 = real(ZH1s_generic)

compare_functions(f1, f2, 1:grid.N, grid)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>compare_functions</code> is not included in the <code>CamiXon</code> package. <img src="assets/compareXH1s.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.demo_hydrogen-Tuple{}" href="#CamiXon.demo_hydrogen-Tuple{}"><code>CamiXon.demo_hydrogen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">demo_hydrogen(; n=3, ℓ=2, codata=castCodata(2018))</code></pre><p>Solves Schrödinger equation for hydrogen atom with principal quantum number <code>n</code> and rotational quantum number <code>ℓ</code>.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">Ecal, grid, def, adams = demo_hydrogen(n=1, ℓ=0);
    Def created for hydrogen 1s on exponential grid of 100 points

E = 1.5Ecal
E, def, adams, Z = adams_moulton_master(E, grid, def, adams; Δν=Value(1,&quot;kHz&quot;), imax=25, msg=true);

plot_wavefunction(Z, 1:def.pos.N, grid, def; reduced=false)</code></pre><p>The plot is made using <code>CairomMakie</code>. Note the discontinuity in the derivative. NB.: <code>plot_wavefunction</code> is not included in the <code>CamiXon</code> package. <img src="assets/hydrogen-1s.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h4 id="Some-special-cases"><a class="docs-heading-anchor" href="#Some-special-cases">Some special cases</a><a id="Some-special-cases-1"></a><a class="docs-heading-anchor-permalink" href="#Some-special-cases" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.RH1s-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U&lt;:Real, T&lt;:Real}" href="#CamiXon.RH1s-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U&lt;:Real, T&lt;:Real}"><code>CamiXon.RH1s</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RH1s(Z::U, r::T) where {U &lt;: Real, T &lt;:Real}</code></pre><p>Analytic expression for the <em>hydrogenic</em> 1s radial wavefunction and its derivative in the format <span>$Z = \tilde{R} + i \tilde{R}^′$</span>, where</p><p class="math-container">\[    \tilde{R}_{1s}(ρ) = Z^{3/2} 2 e^{-Zρ}\]</p><p>is the radial wavefunction and</p><p class="math-container">\[    \tilde{R}^′_{1s}(ρ) = -Z^{5/2} 2 e^{-Zρ}\]</p><p>its derivative, with <span>$ρ$</span> the radial distance to the nucleus in a.u..</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">atom = castAtom(Z=1, A=1, Q=0; msg=false);
orbit = castOrbit(n=1, ℓ=0; msg=false);
grid = autoGrid(atom, orbit, Float64; Nboost=1, msg=false);
def = castDef(grid, atom, orbit, codata);

RH1s_example = [RH1s(atom.Z, grid.r[n]) for n=1:grid.N];

plot_wavefunction(RH1s_example, 1:grid.N, grid, def; reduced=false)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_function</code> is not included in the <code>CamiXon</code> package. <img src="assets/RH1s.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.RH2s-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U&lt;:Real, T&lt;:Real}" href="#CamiXon.RH2s-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U&lt;:Real, T&lt;:Real}"><code>CamiXon.RH2s</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RH2s(Z::U, r::T) where {U &lt;: Real, T &lt;:Real}</code></pre><p>Analytic expression for the <em>hydrogenic</em> 1s reduced radial wavefunction and its derivative in the format <span>$Z = \tilde{R} + i \tilde{R}^′$</span>, where</p><p class="math-container">\[    \tilde{R}_{2s}(ρ)=\left(Z/2\right)^{3/2}(1-Zρ/2)2e^{-Zρ/2}\]</p><p>is the radial wavefunction and</p><p class="math-container">\[    \tilde{R}_{2s}(ρ)=-\left(Z/2\right)^{5/2}(2-Zρ/2)2e^{-Zρ/2}\]</p><p>its derivative, with <span>$ρ$</span> the radial distance to the nucleus in a.u..</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">atom = castAtom(Z=1, A=1, Q=0; msg=false);
orbit = castOrbit(n=2, ℓ=0; msg=false);
grid = autoGrid(atom, orbit, Float64; Nboost=1, msg=false);
def = castDef(grid, atom, orbit, codata; msg=false);

RH2s_example = [RH2s(atom.Z, grid.r[n]) for n=1:grid.N];

plot_wavefunction(RH2s_example, 1:grid.N, grid, def; reduced=false)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_wavefunction</code> is not included in the <code>CamiXon</code> package. <img src="assets/RH2s.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.RH2p-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U&lt;:Real, T&lt;:Real}" href="#CamiXon.RH2p-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U&lt;:Real, T&lt;:Real}"><code>CamiXon.RH2p</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RH2p(Z::U, r::T) where {U &lt;: Real, T &lt;:Real}</code></pre><p>Analytic expression for the <em>hydrogenic</em> 1s reduced radial wavefunction and its derivative in the format <span>$Z = \tilde{R} + i \tilde{R}^′$</span>, where</p><p class="math-container">\[    \tilde{R}_{2p}(ρ)=\left(Z/2\right)^{3/2}\sqrt{1/3}(Zρ/2)2e^{-Zρ/2}\]</p><p>is the radial wavefunction and</p><p class="math-container">\[    \tilde{R}_{2p}(ρ)=\left(Z/2\right)^{3/2}\sqrt{1/3}(1-Zρ/2)2e^{-Zρ/2}\]</p><p>its derivative, with <span>$ρ$</span> the radial distance to the nucleus in a.u..</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">atom = castAtom(Z=1, A=1, Q=0; msg=false);
orbit = castOrbit(n=2, ℓ=1; msg=false);
grid = autoGrid(atom, orbit, Float64; Nboost=1, msg=false);
def = castDef(grid, atom, orbit, codata);

RH2p_example = [RH2p(atom.Z, grid.r[n]) for n=1:grid.N];

plot_wavefunction(RH2p_example, 1:grid.N, grid, def; reduced=false)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_wavefunction</code> is not included in the <code>CamiXon</code> package. <img src="assets/RH2p.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h2 id="Thermodynamic-properties"><a class="docs-heading-anchor" href="#Thermodynamic-properties">Thermodynamic properties</a><a id="Thermodynamic-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Thermodynamic-properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.melting_point-Tuple{Int64}" href="#CamiXon.melting_point-Tuple{Int64}"><code>CamiXon.melting_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">melting_point(atomicnumber::Int)
melting_point(element::String)</code></pre><p>Melting point of a given <code>element</code> at standard pressure (1 atm).</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; melting_point(&quot;Li&quot;)
453.65</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.svp-Tuple{Int64, Real}" href="#CamiXon.svp-Tuple{Int64, Real}"><code>CamiXon.svp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">svp(atomicnumber::Int, temp::Real)
svp(element::String, temp::Real)</code></pre><p>Saturated vapor pressure, <em>p</em> (in Pa), of a given <code>element</code> for a given  temperature <em>T</em> (in K),</p><p class="math-container">\[\mathrm{log_{e}}p=A+B/T+C\mathrm{log_{10}}T+D\cdot T/1000,\]</p><p>where A,B,C,D, are the Antoine coefficients collected in  <a href="#CamiXon.dictAntoineCoefficients"><code>CamiXon.dictAntoineCoefficients</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; svp(&quot;Li&quot;, 623.0)
0.0015230367024569058</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.latent_heat_vaporization-Tuple{Int64, Real}" href="#CamiXon.latent_heat_vaporization-Tuple{Int64, Real}"><code>CamiXon.latent_heat_vaporization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">latent_heat_vaporization(atomicnumber::Int, temp::Real)
latent_heat_vaporization(element::String, temp:Real)</code></pre><p>Latent heat of vaporization, <em>L</em>(<em>T</em>) (in Joule/K), of a given <code>element</code>  for temperature <em>T</em> (in K), </p><p class="math-container">\[L(T) = -(B +C\cdot T \mathrm{log_{10}}T+D\cdot T^2/1000),\]</p><p>where A,B,C,D, are the Antoine coefficients collected in  <a href="#CamiXon.dictAntoineCoefficients"><code>CamiXon.dictAntoineCoefficients</code></a>.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; latent_heat_vaporization(&quot;Li&quot;, 623.0)
-18473.64020109123</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h2 id="Angular-momentum"><a class="docs-heading-anchor" href="#Angular-momentum">Angular momentum</a><a id="Angular-momentum-1"></a><a class="docs-heading-anchor-permalink" href="#Angular-momentum" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.CGC-NTuple{6, Real}" href="#CamiXon.CGC-NTuple{6, Real}"><code>CamiXon.CGC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CGC(j1::Real, m1::Real, j2::Real, m2::Real, J::Real, M::Real; msg=false)</code></pre><p>Clebsch-Gordan coefficient (CGC). This is a vector-coupling coefficient in Dirac notation. The CGCs are zero unless <span>$Δ(j_{1},j_{2},j_{3})&gt;0$</span> (triangle inequality holds) and <span>$M=m_{1}+m_{2}$</span>. The relation to the Wigner 3j symbols is given by:</p><p class="math-container">\[\langle j_{1}m_{1};j_{2}m_{2}|JM\rangle\equiv
(-1)^{j_{1}-j_{2}+M}\sqrt{2J+1}\left(\begin{array}{ccc}
j_{1} &amp; j_{2} &amp; J\\
m_{1} &amp; m_{2} &amp; -M
\end{array}\right)\]</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; j1=3; m1=0; j2=4; m2=-1; J=5; M=-1;

julia&gt; a = CGC(j1, m1, j2, m2, J, M)
-0.36364052611670255269921486774521555203216489725107181148303161368088211274565

julia&gt; b = (-1)^(j1-j2+M) * sqrt(2J+1) * threeJsymbol(j1, m1, j2, m2, J, -M)
-0.36364052611670255269921486774521555203216489725107181148303161368088211274565

julia&gt; o = CGC(j1, m1, j2, m2, J, M; msg=true); println(&quot; = $o&quot;)
-√(361/2730) = -0.36364052611670255269921486774521555203216489725107181148303161368088211274565</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.threeJsymbol-NTuple{6, Real}" href="#CamiXon.threeJsymbol-NTuple{6, Real}"><code>CamiXon.threeJsymbol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">threeJsymbol(j1::Real, m1::Real, j2::Real, m2::Real, j3::Real, m3::Real; msg=false)</code></pre><p>Wigner 3j symbol. This is a vector coupling coefficient with optimized symmetry properties. The 3j symbols are zero unless <span>$Δ(j_{1},j_{2},j_{3})&gt;0$</span> (triangle inequality holds) and <span>$m_{1}+m_{2}+m_{3}=0$</span>. The implementation is based on the Racah formula:</p><p class="math-container">\[\left(\begin{array}{ccc}
j_{1} &amp; j_{2} &amp; j_{3}\\
m_{1} &amp; m_{2} &amp; m_{3}
\end{array}\right)=
(-1)^{j_{1}-j_{2}-m_{3}}\sqrt{\Delta(j_{1}j_{2}J)}\\\times
\sqrt{\left(j_{1}+m_{1}\right)!
\left(j_{1}-m_{1}\right)!
\left(j_{2}+m_{2}\right)!
\left(j_{2}-m_{2}\right)!
\left(j_{3}+m_{3}\right)!
\left(j_{3}-m_{3}\right)!}
\\\times\sum_{t}\frac{(-)^{t}}{t!(j_{3}-j_{2}+t+m_{1})!
(j_{3}-j_{1}+t-m_{2})!
(j_{1}+j_{2}-j_{3}-t)!(j_{1}-t-m_{1})!(j_{2}-t+m_{2})!}\]</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; threeJsymbol(0, 0, 0, 0, 0, 0)
1.0

julia&gt; threeJsymbol(3, 0, 4, -1, 5, 1)
-0.1096417439724123565166029917781360897459044055433631161836138910409772907333476

julia&gt; o = threeJsymbol(3, 0, 4, -1, 5, 1; msg=true); println(&quot; = $o&quot;)
-√(361/30030) = -0.1096417439724123565166029917781360897459044055433631161836138910409772907333476</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h2 id="Grid"><a class="docs-heading-anchor" href="#Grid">Grid</a><a id="Grid-1"></a><a class="docs-heading-anchor-permalink" href="#Grid" title="Permalink"></a></h2><p>The <code>Grid</code> object is the backbone for the numerical procedure on a non-uniform grid. Its principal fields are <code>grid.r</code> and <code>grid.r′</code>, which are discrete functions of <code>N</code> elements representing the grid function and its derivative.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.Grid" href="#CamiXon.Grid"><code>CamiXon.Grid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Grid(ID, name, T, N, r, r′, h, r0, epn, epw, k)</code></pre><p>Type with fields:</p><ul><li><code>.ID</code>:   grid identifer name (<code>::Int</code>)</li><li><code>.name</code>: grid identifer name (<code>::String</code>)</li><li><code>.T</code>:    gridType (<code>::Type</code>)</li><li><code>.N</code>:    number of grid points (<code>::Int</code>)</li><li><code>.r</code>:   tabulated grid function (<code>::Vector{T}</code>)</li><li><code>.r′</code>:   tabulated derivative of grid function (<code>::Vector{T}</code>)</li><li><code>.h</code> :   grid step multiplyer (<code>::T</code>)</li><li><code>.r0</code>:   grid scale factor (<code>::T</code>)</li><li><code>.epn</code>:  number of endpoints used for trapezoidal endpoint correction (must be odd) (<code>::Int</code>)</li><li><code>.epw</code>:  trapezoidal endpoint weights for n=1:epn (<code>::Vector{Vector{T}}</code>)</li><li><code>.k</code>:    Adams-Moulton order (<code>::Int</code>)</li></ul><p>The object <code>Grid</code> is best created with the function <a href="#CamiXon.castGrid-Tuple{Int64, Int64, Type}"><code>castGrid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.gridname-Tuple{Int64}" href="#CamiXon.gridname-Tuple{Int64}"><code>CamiXon.gridname</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gridname(ID::Int)</code></pre><p>Name corresponding to the grid ID.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">n = gridname(2); println(&quot;The grid type with ID = 2 is called &#39;$n&#39;.&quot;)
  The grid type with ID = 2 is called &#39;quasi-exponential&#39;.</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real" href="#CamiXon.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiXon.gridfunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gridfunction(ID::Int, n::Int, h::T; p=5, coords=[0,1], deriv=0) where T &lt;: Real</code></pre><ul><li><code>ID = 1</code>: exponential grid function,</li></ul><p class="math-container">\[    f[n] = \text{exp}(h(n-1)) - 1.0\]</p><ul><li><code>ID = 2</code>: quasi-exponential grid function degree <code>p</code> (linear grid for <code>p = 1</code>),</li></ul><p class="math-container">\[    f[n] = h(n-1) + \frac{1}{2}(h(n-1))^2 + ⋯ + \frac{1}{p!}(h(n-1))^p\]</p><ul><li><code>ID = 3</code>: linear grid function,</li></ul><p class="math-container">\[    f[n] = h(n-1)\]</p><ul><li><code>ID = 4</code>: polynomial grid function of degree <code>p = length(c)</code> based on <code>polynom</code> <span>$c = [c_1,c_2,⋯\ c_p]$</span>,</li></ul><p class="math-container">\[    f[n] = c_1h(n-1) + c_2(h(n-1))^2 + ⋯ + c_p(h(n-1))^p\]</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">h = 0.1
r = [gridfunction(1, n-1, h) for n=1:5]                            # exponential
 [0.0, 0.10517091807564771, 0.22140275816016985, 0.3498588075760032, 0.49182469764127035]

r = [gridfunction(2, n-1, h; p = 4) for n=1:5]  # quasi exponential (degree p=4)
 [0.0, 0.10517083333333321, 0.22140000000000004, 0.3498375, 0.49173333333333336]

r = [gridfunction(3, n-1, h) for n=1:5]              # linear
  [0.0, 0.1, 0.2, 0.3, 0.4]

r′= [gridfunction(3, n-1, h; deriv=1) for n=1:5]     # linear (first derivative)
   [0.1, 0.1, 0.1, 0.1, 0.1]

  r = [gridfunction(4, n-1, h; coords = [0,1,1/2,1/6,1/24]) for n=1:5]  # polynomial of degree 4)
   [0.0, 0.10517083333333334, 0.2214, 0.3498375000000001, 0.49173333333333336]</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.castGrid-Tuple{Int64, Int64, Type}" href="#CamiXon.castGrid-Tuple{Int64, Int64, Type}"><code>CamiXon.castGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">castGrid(ID::Int, N::Int, T::Type; h=1, r0=1,  p=5, coords=[0,1], epn=5, k=7, msg=false)</code></pre><p>Method to create the Grid object</p><p><code>ID = 1</code>: exponential grid, <code>ID = 2</code>: quasi-exponential grid, <code>ID = 3</code>: linear grid <code>ID = 4</code>: polynomial grid</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">h = 0.1
r0 = 1.0
grid = castGrid(1, 4, Float64; h, r0, msg=true)
grid.r
  create exponential Grid: Float64, Rmax = 0.491825 a.u., Ntot = 4, h = 0.1, r0 = 1.0
  [1.0e-100, 0.10517091807564771, 0.22140275816016985, 0.3498588075760032]

grid = castGrid(2, 4, Float64; p = 4, h, r0, msg=true))
grid.r
  create quasi-exponential Grid: Float64, Rmax = 0.491733 a.u., Ntot = 4, p = 4, h = 0.1, r0 = 1.0
  [1.0e-100, 0.10517083333333321, 0.22140000000000004, 0.3498375]

grid = castGrid(3, 4, Float64; coords=[0, 1, 1/2, 1/6, 1/24], h, r0, msg=true)
grid.r
  create polynomial Grid: Float64, Rmax = 0.491733 a.u., Ntot = 4, coords = [0.0, 1.0, 0.5, 0.166666, 0.0416666], h = 0.1, r0 = 1.0
  [1.0e-100, 0.10517083333333334, 0.2214, 0.3498375000000001]

grid = castGrid(4, 4, Float64; h, r0, msg=true)
grid.r
  create linear Grid: Float64, Rmax = 0.4 a.u., Ntot = 4, p = 1, h = 0.1, r0 = 1.0
  [1.0e-100, 0.1, 0.2, 0.3]

grid.r′
  [0.1, 0.1, 0.1, 0.1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.findIndex-Union{Tuple{T}, Tuple{T, Grid{T}}} where T&lt;:Number" href="#CamiXon.findIndex-Union{Tuple{T}, Tuple{T, Grid{T}}} where T&lt;:Number"><code>CamiXon.findIndex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findIndex(rval::T, grid::Grid{T}) where T&lt;:Number</code></pre><p>The grid index corresponding to the position <code>rval</code> on the <code>grid</code>.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">h = 0.1
r0 = 1.0
grid = castGrid(1, 4, Float64; h, r0)
r = grid.r; println(&quot;r[3] = $(r[3])&quot;)
  Grid created: exponential, Float64, Rmax = 0.491825 a.u., Ntot = 4, h = 0.1, r0 = 1.0
  r[3] = 0.22140275816016985

findIndex(0.222, grid)
  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.autoRmax-Tuple{Atom, Orbit}" href="#CamiXon.autoRmax-Tuple{Atom, Orbit}"><code>CamiXon.autoRmax</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autoRmax(atom::Atom, orbit::Orbit)</code></pre><p>Largest relevant radial distance in a.u. (rule of thumb value)</p><p class="math-container">\[    R_{max} = (2n^2 + 20n + 62)/Zc,\]</p><p>where <span>$n$</span> is the principal quantum number and <span>$Z_c$</span> the Rydberg charge</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">codata = castCodata(2018)
atom = castAtom(Z=1, A=1, Q=0)
orbit = castOrbit(n=1, ℓ=0)
rmax = autoRmax(atom::Atom, orbit::Orbit); println(&quot;rmax = $(rmax) a.u.&quot;)
    Element created: H, hydrogen, Z=1, weight=1.008
    Isotope created: ¹H, hydrogen, Z=1, A=1, N=0, R=0.8783, M=1.007825032, I=1/2⁺, μI=2.792847351, Q=0.0, RA=99.9855%, (stable)
    Atom created: hydrogen, neutral atom, ¹H, Z=1, A=1, Q=0, Zc=1
    Orbital: 1s
        principal quantum number: n = 1
        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)
        orbital angular momentum of valence electron: ℓ = 0
    rmax = 63.0 a.u.</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.autoNtot-Tuple{Orbit}" href="#CamiXon.autoNtot-Tuple{Orbit}"><code>CamiXon.autoNtot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autoNtot(orbit::Orbit, Nboost=1)</code></pre><p>Total number of gridpoints (rule of thumb value)</p><p class="math-container">\[    N_{tot} = (70 + 50 * n) * N_{boost},\]</p><p>where <span>$n$</span> is the principal quantum number and <code>Nboost</code> a multiplier to boost numerical precision</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">orbit = castOrbit(n=1, ℓ=0)
autoNtot(orbit)
 Orbit created: 1s - (n = 1, n′ = 0, ℓ = 0)

 100</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.autoPrecision-Union{Tuple{T}, Tuple{T, Orbit}} where T&lt;:Real" href="#CamiXon.autoPrecision-Union{Tuple{T}, Tuple{T, Orbit}} where T&lt;:Real"><code>CamiXon.autoPrecision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autoPrecision(Rmax::T, orbit::Orbit) where T&lt;:Real</code></pre><p>Floating point precision (rule of thumb value)</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">atom = castAtom(Z=1)
orbit = castOrbit(n=1,ℓ=0)
Rmax = autoRmax(atom, orbit)
o = autoPrecision(Rmax, orbit); println(&quot;precision = $o&quot;)
    Element created: H, hydrogen, Z=1, weight=1.008
    Isotope created: ¹H, hydrogen, Z=1, A=1, N=0, R=0.8783, M=1.007825032, I=1/2⁺, μI=2.792847351, Q=0.0, RA=99.9855%, (stable)
    Atom created: hydrogen, neutral atom, ¹H, Z=1, A=1, Q=0, Zc=1
    Orbital: 1s
        principal quantum number: n = 1
        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)
        orbital angular momentum of valence electron: ℓ = 0
    precision = Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.autoSteps-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real" href="#CamiXon.autoSteps-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiXon.autoSteps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autoSteps(ID::Int, Ntot::Int, Rmax::T; p=5) where T&lt;:Real
autoSteps(ID::Int, Ntot::Int, Rmax::T; coords=[0,1]) where T&lt;:Real</code></pre><p>Step size parameter (h) and range parameter (r0) (rule of thumb values).</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">(h, r0) = autoSteps(1, 100, 100)
    (0.1, 0.004540199100968777)</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.autoGrid-Tuple{Atom, Orbit, Type}" href="#CamiXon.autoGrid-Tuple{Atom, Orbit, Type}"><code>CamiXon.autoGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autoGrid(atom, orbit,  T; Nboost=1, epn=5, k=7, msg=true, p=0)
autoGrid(atom, orbits, T; Nboost=1, epn=5, k=7, msg=true, p=0)
autoGrid(atom, orbit,  T; Nboost=1, epn=5, k=7, msg=true, coords=[])
autoGrid(atom, orbits, T; Nboost=1, epn=5, k=7, msg=true, coords=[])</code></pre><p>Automatic setting of grid parameters for a given orbit <a href="#CamiXon.Orbit"><code>Orbit</code></a> or an array of orbits - <code>orbits = [orbit1, orbit2, ⋯]</code>. Important cases:</p><ul><li><code>p == 0</code> (exponential radial grid)</li><li><code>p == 1</code> (linear radial grid)</li><li><code>p &gt; 1</code> (quasi-exponential radial grid)</li><li><code>coords=[]</code> (free polynomial grid based on the <code>coords</code>)</li><li><code>Nboost</code> (multiplier to boost numerical precision)</li><li><code>epn</code> (endpoint number: odd number to be used for trapezoidal integration with endpoint correction)</li><li><code>k</code> (Adams-Moulton order to be used for <code>k+1</code>-point Adams-Moulton integration)</li></ul><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">codata = castCodata(2018)
atom = castAtom(;Z=1, A=1, Q=0, msg=false)
orbit = castOrbit(n=75, ℓ=0, msg=false)
grid = autoGrid(atom, orbit, Float64);
    Grid created: exponential, Float64, Rmax = 16935.0 a.u., Ntot = 3800, h = 0.00263158, r0 = 0.768883

plot_gridfunction(grid, 1:grid.N; title=&quot;&quot;)</code></pre><p>The plot is made using CairomMakie. NB.: <code>plot_gridfunction</code> is not part of the <code>CamiXon</code> package. <img src="assets/exponential_grid.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.grid_differentiation-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T&lt;:Real" href="#CamiXon.grid_differentiation-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T&lt;:Real"><code>CamiXon.grid_differentiation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grid_differentiation(f::Vector{T}, grid::Grid{T}; k=3) where T&lt;:Real</code></pre><p><span>$k^{th}$</span>-order lagrangian <em>differentiation</em> of the analytic function <span>$f$</span>, tabulated in forward order on a <a href="#Grid"><code>Grid</code></a> of <span>$n$</span> points, <span>$f[1:n]$</span>.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">ID = 4 # linear grid
f = [0.0, 1.0, 4.0, 9.0, 16.0, 25.0]
grid = castGrid(ID, length(f), Float64; r0=1.0, h=1.0, k=3)  # linear grid
f′= grid_differentiation(f, grid; k=3); println(&quot;f′= $(f′)&quot;)
  Grid created: linear, Float64, Rmax = 6.0 a.u., Ntot = 6, p = 1, h = 1.0, r0 = 1.0
  f′= [0.0, 2.0, 4.0, 6.0, 7.999999999999998, 9.999999999999993]</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.grid_integration-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, Int64, Int64, Grid{V}}} where {T&lt;:Real, V&lt;:Real}" href="#CamiXon.grid_integration-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, Int64, Int64, Grid{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.grid_integration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grid_integration(f::Vector{T}, n1::Int, n2::Int, grid::Grid{V}) where {T&lt;:Real, V&lt;:Real}</code></pre><p>Integral of the function <span>$f=[f_0,⋯\ f_n]$</span> tabulated on a <a href="#Grid"><code>Grid</code></a> using the trapezoidal rule optimized with endpoint correction by the weightsvector <code>grid.epw</code>,</p><p class="math-container">\[    ∫_{0}^{r_n} f(r) dr = ∫_{0}^{n} f(x) r^{\prime}(x) dx,\]</p><p>where the latter integral corresponds to the optimized trapezoidal rule for a uniform grid (see <a href="#CamiXon.trapezoidal_integration-NTuple{4, Any}"><code>trapezoidal_integration</code></a>). The rule is exact for polynonials of degree <span>$d=0,\ 1,⋯\ k-1$</span>, where <span>$k=$</span> <code>grid.epn</code>. For <span>$k=1$</span> the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">f1s(r) = 2.0*r*exp(-r);  # hydrogen 1s wavefunction (reduced and unit normalized)
N = 1000;
grid = castGrid(1, N, Float64; h=0.01, r0=0.005)
    create exponential Grid: Float64, Rmax = 110.127 (a.u.), Ntot = 1000, h = 0.01, r0 = 0.005

r = grid.r;
f2 = [f1s(r[n])^2 for n=1:N];
grid_integration(f2, 1:N, grid) == grid_integration(f2, 1, N, grid)
    true

norm = grid_integration(f2, 1:N, grid)

    1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h2 id="Adams-Moulton-integration"><a class="docs-heading-anchor" href="#Adams-Moulton-integration">Adams-Moulton integration</a><a id="Adams-Moulton-integration-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Moulton-integration" title="Permalink"></a></h2><p>The Adams-Moulton method is used for numerical integration of the reduces radial wave equation. In the present implementation it is constructed on top the objects <a href="#CamiXon.Atom"><code>Atom</code></a>, <a href="#CamiXon.Orbit"><code>Orbit</code></a>, <a href="#Grid"><code>Grid</code></a>, <a href="#Def"><code>Def</code></a> and <a href="#Adams"><code>Adams</code></a> using 5 globally defined instances called <code>atom</code>, <code>orbit</code>, <code>grid</code>, <code>def</code> and <code>adams</code>.</p><h3 id="Def"><a class="docs-heading-anchor" href="#Def">Def</a><a id="Def-1"></a><a class="docs-heading-anchor-permalink" href="#Def" title="Permalink"></a></h3><p>The <code>Def</code> object serves to define the problem to be solved and to contain in the field <code>def.Z</code> the solution as a discrete function of <code>N</code> elements.</p><h4 id="Illustration:-central-field-potential-U_{\\mathrm{CF}}-versus-grid-index"><a class="docs-heading-anchor" href="#Illustration:-central-field-potential-U_{\\mathrm{CF}}-versus-grid-index">Illustration: central field potential <span>$U_{\mathrm{CF}}$</span> versus grid index</a><a id="Illustration:-central-field-potential-U_{\\mathrm{CF}}-versus-grid-index-1"></a><a class="docs-heading-anchor-permalink" href="#Illustration:-central-field-potential-U_{\\mathrm{CF}}-versus-grid-index" title="Permalink"></a></h4><pre><code class="nohighlight hljs">codata = castCodata(2018)
atom = castAtom(Z=1, A=1, Q=0)
orbit = castOrbit(n=7, ℓ=2)
grid = autoGrid(atom, orbit, Float64)
def = castDef(grid, atom, orbit, codata)
E = convert(grid.T,bohrformula(atom.Z, orbit.n))
adams = castAdams(E, grid, def)
@printf &quot;E = %.15g %s \n&quot; E &quot;Hartree&quot;
    Element created: H, hydrogen, Z=1, weight=1.008
    Isotope created: ¹H, hydrogen, Z=1, A=1, N=0, R=0.8783, M=1.007825032, I=1/2⁺, μI=2.792847351, Q=0.0, RA=99.9855%, (stable)
    Atom created: hydrogen, neutral atom, ¹H, Z=1, A=1, Q=0, Zc=1
    Orbital: 7d
        principal quantum number: n = 7
        radial quantum number: n′ = 4 (number of nodes in radial wavefunction)
        orbital angular momentum of valence electron: ℓ = 2
    Grid created: exponential, Float64, Rmax = 207.0 a.u., Ntot = 400, h = 0.025, r0 = 0.00939821
    Def created for hydrogen 7d on exponential grid of 400 points
    E = -0.0102040816326531 Hartree

plot_potentials(E, grid, def)
    Nlctp = 234, Nmin = 259, Nuctp = 369 (Ructp = 93.0059202490 a.u.)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_potentials</code> is not included in the <code>CamiXon</code> package. <img src="assets/potential.png" alt="Image"/></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.Def" href="#CamiXon.Def"><code>CamiXon.Def</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Def(T, atom, orbit, pot, scr, o1, o2, o3, pos, epn, k, am, matLD)</code></pre><p>Type with fields:</p><ul><li><code>.T</code>: gridType (<code>::Type</code>)</li><li><code>.atom</code>: atom object (<code>::Atom</code>)</li><li><code>.orbit</code>: orbit object (<code>::Orbit</code>)</li><li><code>.codata</code>: codata object (<code>::Codata</code>)</li><li><code>.pot</code>: tabulated potential function (<code>::Vector{T}</code>)</li><li><code>.scr</code>: tabulated screening function (<code>::Vector{T}</code>)</li><li><code>.o1</code>: vector of zero-filled matrices (<code>::Vector{Matrix{T}}</code>)</li><li><code>.o2</code>: vector of zero-filled matrices (<code>::Vector{Matrix{T}}</code>)</li><li><code>.o3</code>: vector of unit-filled matrices (<code>::Vector{Matrix{T}}</code>)</li><li><code>.pos</code>: object containing Na, Nlctp, Nmin, Nuctp, Nb, N and nodes (<code>::Pos</code>)</li><li><code>.epn</code>: number of endpoints trapezoidal correction - must be odd (<code>::Int</code>)</li><li><code>.k</code>: Adams-Moulton order (<code>::Int</code>)</li><li><code>.am</code>: Adams-Moulton weight coefficients (<code>::Vector{T}</code>)</li><li><code>.matLD</code>: Lagrangian differentiation matrix (<code>::Matrix{T}</code>)</li></ul><p>The object <code>Def</code> is best created with the function <a href="#CamiXon.castDef-Union{Tuple{T}, Tuple{Grid{T}, Atom, Orbit, Codata}} where T&lt;:Real"><code>castDef</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.castDef-Union{Tuple{T}, Tuple{Grid{T}, Atom, Orbit, Codata}} where T&lt;:Real" href="#CamiXon.castDef-Union{Tuple{T}, Tuple{Grid{T}, Atom, Orbit, Codata}} where T&lt;:Real"><code>CamiXon.castDef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">castDef(grid::Grid{T}, atom::Atom, orbit::Orbit, codata::Codata[; scr=nothing[, msg=true]]) where T &lt;: Real</code></pre><p>Create the <a href="#Def"><code>Def</code></a> object starting from the <a href="#Grid"><code>Grid</code></a> object and the atomic properties of the objects <a href="#CamiXon.Atom"><code>Atom</code></a> and <a href="#CamiXon.Orbit"><code>Orbit</code></a>. Optional: scr (supply screening array)</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">codata = castCodata(2018)
atom = castAtom(Z=1, A=1, Q=0)
orbit = castOrbit(n=7, ℓ=2)
grid = autoGrid(atom, orbit, Float64)
def = castDef(grid, atom, orbit, codata);
    Element created: H, hydrogen, Z=1, weight=1.008
    Isotope created: ¹H, hydrogen, Z=1, A=1, N=0, R=0.8783, M=1.007825032, I=1/2⁺, μI=2.792847351, Q=0.0, RA=99.9855%, (stable)
    Atom created: hydrogen, neutral atom, ¹H, Z=1, A=1, Q=0, Zc=1
    Orbital: 7d
        principal quantum number: n = 7
        radial quantum number: n′ = 4 (number of nodes in radial wavefunction)
        orbital angular momentum of valence electron: ℓ = 2
    Grid created: exponential, Float64, Rmax = 207.0 a.u., Ntot = 400, h = 0.025, r0 = 0.00939821
    Def created for hydrogen 7d on exponential grid of 400 points</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h4 id="Pos-and-Pos-related-functions"><a class="docs-heading-anchor" href="#Pos-and-Pos-related-functions">Pos and Pos-related functions</a><a id="Pos-and-Pos-related-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Pos-and-Pos-related-functions" title="Permalink"></a></h4><p>The <code>Pos</code> object serves within <a href="#Def"><code>Def</code></a> object to contain the position indices <code>def.Na</code>, <code>def.Nb</code>, <code>def.Nlctp</code>, <code>def.Nmin</code>, <code>def.Nuctp</code> used in Adams-Moulton integration. These positions are contained in the fields <code>def.pos.Na</code>, <code>def.pos.Nb</code>, <code>def.pos.Nlctp</code>, <code>def.pos.Nmin</code>, <code>def.pos.Nuctp</code>. Alternatively, they can be determined with the functions <a href="#CamiXon.get_Na-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>get_Na</code></a>, <a href="#CamiXon.get_Nb-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>get_Nb</code></a>, <a href="#CamiXon.get_Nlctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>get_Nlctp</code></a>, <a href="#CamiXon.get_Nmin-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real"><code>get_Nmin</code></a>, <a href="#CamiXon.get_Nuctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>get_Nuctp</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.Pos" href="#CamiXon.Pos"><code>CamiXon.Pos</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pos(Na::Int, Nlctp::Int, Nmin::Int, Nuctp::Int, Nb::Int, N::Int, nodes::Int, cWKB::Float64)</code></pre><p>Type with fields:</p><ul><li><code>.Na</code>: grid index of last leading point (<code>::Int</code>)</li><li><code>.Nlctp</code>: grid index of lower classical turning point (<code>::Int</code>)</li><li><code>.Nmin</code>: grid index of (screened) potential minimum (<code>::Int</code>)</li><li><code>.Nuctp</code>: grid index of upper classical turning point (<code>::Int</code>)</li><li><code>.Nb</code>: grid index first trailing point (<code>::Int</code>)</li><li><code>.N</code>: grid index last point (<code>::Int</code>)</li><li><code>.nodes</code>: number of nodes  (<code>::Int</code>)</li><li><code>.cWKB</code>: WKB threshold level determining Na and Nb (<code>::Float64</code>)</li></ul><p>Mutable struct to hold special grid indices as well as the number of nodes; <code>Pos</code> is one of the fields of the <a href="#Def"><code>Def</code></a> object</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">pos = Pos(1, 2, 3, 4, 5, 6, 7, 8)
pos.Nuctp
    4

pos.Nuctp = 8
pos
    Pos(1, 2, 3, 9, 5, 6, 7, 8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.get_Na-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real" href="#CamiXon.get_Na-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Na</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Na(Z::Vector{Complex{T}}, def::Def{T}) where T&lt;:Real</code></pre><p>Grid index of the starting point for outward numerical integration. This is <code>k+1</code> or the point marking the end of the quasiclassical region below the lower classical turning point (<code>lctp</code>) as marked by the WKB threshold value (<code>def.pos.cWKB</code>).</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">Ecal, grid, def, adams = demo_hydrogen(n=1, ℓ=0)
E, def, adams, Z = adams_moulton_master(E, codata, grid, def, adams; Δν=Value(1,&quot;kHz&quot;), imax=25, msg=false);
    Orbital: 1s
        principal quantum number: n = 1
        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)
        orbital angular momentum of valence electron: ℓ = 0
    Grid created: exponential, Float64, Rmax = 63.0 a.u., Ntot = 100, h = 0.1, r0 = 0.00286033
    Def created for hydrogen 1s on exponential grid

Na = get_Na(Z, def)
println(&quot;k + 1 = $(grid.k+1); Na = $Na&quot;)
    k + 1 = 8; Na = 8

Na == def.pos.Na
    true</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.get_Nb-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real" href="#CamiXon.get_Nb-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Nb(Z::Vector{Complex{T}}, def::Def{T}) where T&lt;:Real</code></pre><p>Grid index of the stopping for outward numerical integration. This is <code>N-k-1</code> or the point marking the start of the quasiclassical region above the upper classical turning point (<code>Nuctp</code>) as marked by the WKB threshold value (<code>def.pos.cWKB</code>).</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">Ecal, grid, def, adams = demo_hydrogen(n=1, ℓ=0)
E, def, adams, Z = adams_moulton_master(E, codata, grid, def, adams; Δν=Value(1,&quot;kHz&quot;), imax=25, msg=false);
    Orbital: 1s
        principal quantum number: n = 1
        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)
        orbital angular momentum of valence electron: ℓ = 0
    Grid created: exponential, Float64, Rmax = 63.0 a.u., Ntot = 100, h = 0.1, r0 = 0.00286033
    Def created for hydrogen 1s on exponential grid

Nb = get_Nb(Z, def)
println(&quot;N - k - 1 = $(grid.N-grid.k-1); Nb = $Nb&quot;)
    N - k - 1 = 92; Nb = 92

Nb == def.pos.Nb
    true</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.get_Nlctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real" href="#CamiXon.get_Nlctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nlctp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Nlctp(E::T, def::Def{T}) where T&lt;:Real</code></pre><p>Grid index of the *lower classical turning point * of the screened potential curve. By definition <code>get_Nlctp(E, def) = 2</code> for zero orbital angular momentum (<code>ℓ=0</code>).</p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.get_Nmin-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real" href="#CamiXon.get_Nmin-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.get_Nmin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Nmin(def::Def{T}) where T&lt;:Real</code></pre><p>Grid index of the minimum of the screened potential curve. By definition <code>get_Nmin(def) = 1</code> for zero orbital angular momentum (<code>ℓ=0</code>).</p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.get_Nuctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real" href="#CamiXon.get_Nuctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nuctp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Nuctp(E::T, def::Def{T}) where T&lt;:Real</code></pre><p>Grid index of the <em>upper classical turning point</em> of the screened potential curve. By definition <code>get_Nuctp(E, def) = N-1</code> for zero orbital angular momentum (<span>$ℓ=0$</span>).</p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.count_nodes-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real" href="#CamiXon.count_nodes-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.count_nodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_nodes(Z::Vector{Complex{T}}, def::Def{T}) where T&lt;:Real</code></pre><p>Number of nodes (excluding the origin) of the reduced radial wavefunction χ(r) = real(Z).</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">atom = castAtom(Z=1, A=1, Q=0, msg=false);
orbit = castOrbit(n=3, ℓ=2, msg=false);
grid = autoGrid(atom, orbit, Float64; Nboost=1, epn=5, k=7, msg=false);
def = castDef(grid.T, atom, orbit, codata);
    Def created for hydrogen 3d on exponential grid of 200 points

E = convert(setT, bohrformula(atom.Z, orbit.n));
adams = castAdams(E, grid, def);
E, def, adams, Z = adams_moulton_master(E, codata, grid, def, adams; Δν=Value(1,&quot;kHz&quot;), imax=25, msg=false);

o = count_nodes(Z, def); println(&quot;node count: $o nodes&quot;)
    node count: 0 nodes</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h3 id="Adams"><a class="docs-heading-anchor" href="#Adams">Adams</a><a id="Adams-1"></a><a class="docs-heading-anchor-permalink" href="#Adams" title="Permalink"></a></h3><p>The <code>Adams</code> object serves to hold the Adams-Moulton integration matrices <code>matG</code>, <code>matσ</code>, <code>matMinv</code> as well as the <em>actual</em> normalized solution <code>Z</code> in the form of a tabulated function of <code>N</code> elements.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.Adams" href="#CamiXon.Adams"><code>CamiXon.Adams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Adams{T}</code></pre><ul><li>G: (<code>:Vector{Matrix{T}}</code>)</li><li>σ: (<code>:Vector{Matrix{T}}</code>)</li><li>Minv: (<code>:Vector{Matrix{T}}</code>)</li><li>Z: (<code>:Vector{Complex{T}}</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.castAdams-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real" href="#CamiXon.castAdams-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.castAdams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">castAdams(E::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.updateAdams!-Union{Tuple{T}, Tuple{Adams{T}, Any, Grid{T}, Def{T}}} where T&lt;:Real" href="#CamiXon.updateAdams!-Union{Tuple{T}, Tuple{Adams{T}, Any, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.updateAdams!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updateAdams!(adams::Adams{T}, E, grid::Grid{T}, def::Def{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.initE-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real" href="#CamiXon.initE-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.initE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initE(def::Def{T}) where T&lt;:Real</code></pre><p>Autogenerated seed value for the energy</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">codata = castCodata(2018)
atom = castAtom(Z=1, A=1, Q=0; msg=false)
orbit = castOrbit(n=1, ℓ=0; msg=false)
grid = autoGrid(atom, orbit, Float64; msg=false)
def = castDef(grid, atom, orbit, codata);
    Def created for hydrogen 1s on exponential grid of 100 points

E = initE(def); println(&quot;E = $E&quot;)
    E = -0.03508495857961283</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h4 id="Adams-related-functions"><a class="docs-heading-anchor" href="#Adams-related-functions">Adams related functions</a><a id="Adams-related-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-related-functions" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.matG-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real" href="#CamiXon.matG-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.matG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matG(E::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.matσ-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real" href="#CamiXon.matσ-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.matσ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matσ(E::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.matMinv-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, T}} where T&lt;:Real" href="#CamiXon.matMinv-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, T}} where T&lt;:Real"><code>CamiXon.matMinv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matMinv(E::T, grid::Grid{T}, def::Def{T}, amEnd::T) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h4 id="Adams-Moulton-numerical-solution-of-the-radial-wave-equation"><a class="docs-heading-anchor" href="#Adams-Moulton-numerical-solution-of-the-radial-wave-equation">Adams-Moulton numerical solution of the radial wave equation</a><a id="Adams-Moulton-numerical-solution-of-the-radial-wave-equation-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Moulton-numerical-solution-of-the-radial-wave-equation" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.adams_moulton_solve-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams}} where T&lt;:Real" href="#CamiXon.adams_moulton_solve-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams}} where T&lt;:Real"><code>CamiXon.adams_moulton_solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adams_moulton_solve(E::T, grid::Grid{T}, def::Def{T}, adams::Adams) where T&lt;:Real</code></pre><p>Numerical solution of the 1D Schrödinger equation for the radial motion of a <em>valence</em> electron of energy <code>E</code>. Output: the improved <code>Adams</code> object, the energy convergence <code>ΔE</code>, and <code>Z</code>, where <code>P = real(Z)</code> is the <em>reduced</em> radial wavefunction and <code>Q = imag(Z)</code> its derivative.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">atom = castAtom(Z=1, A=1, Q=0, msg=true)
orbit = castOrbit(n=1, ℓ=0)
grid = autoGrid(atom, orbit, Float64; Nboost=1, msg=true)
def = castDef(grid, atom, orbit, codata)
E = Ecal = convert(grid.T, bohrformula(atom.Z, orbit.n))
adams = castAdams(E, grid, def);

adams, ΔE, Z = adams_moulton_solve(E, grid, def, adams)
plot_wavefunction(Z, 1:grid.N, grid, def; reduced=true)</code></pre><p>The plot is made using CairomMakie. NB.: <code>plot_wavefunction</code> is not part of the <code>CamiXon</code> package. <img src="assets/hydrogen-1s-prepared.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h4 id="Radial-integration-outward"><a class="docs-heading-anchor" href="#Radial-integration-outward">Radial integration - outward</a><a id="Radial-integration-outward-1"></a><a class="docs-heading-anchor-permalink" href="#Radial-integration-outward" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.OUTSCH-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Array{Matrix{T}, 1}}} where T&lt;:Real" href="#CamiXon.OUTSCH-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Array{Matrix{T}, 1}}} where T&lt;:Real"><code>CamiXon.OUTSCH</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OUTSCH(E::T, grid::Grid{T}, def::Def{T}, σ::Vector{Matrix{T}}})) where T&lt;:Real</code></pre><p>Solution of the Schrödinger for the first <span>$k$</span> points on the <code>grid</code>, where <span>$k$</span> is the Adams-Moulton order. The WKB solution for energy <code>E</code> is used when the WKB approximation is valid (for nonzero angular momentum at distances below the inner classical turning point - ictp)</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">Ecal, grid, def, adams = demo_hydrogen(n=1, ℓ=0)
Z = OUTSCH(Ecal, grid, def, adams.σ)
println(&quot;\nZ: standard Ansatz for wavefunction (n &lt; Na=$(def.pos.Na)))&quot;)
    Orbital: 1s
        principal quantum number: n = 1
        radial quantum number: n′ = 0 (number of nodes in radial wavefunction)
        orbital angular momentum of valence electron: ℓ = 0
    Grid created: exponential, Float64, Rmax = 63.0 a.u., Ntot = 100, h = 0.1, r0 = 0.00286033
    Def created for hydrogen 1s on exponential grid

    Z: standard Ansatz for wavefunction (n &lt; Na=8))

Ecal, grid, def, adams = demo_hydrogen(n=10, ℓ=5)
Z = OUTSCH(Ecal, grid, def, adams.σ);
println(&quot;\nZ: WKB Ansatz for wavefunction (n &lt; Na=$(def.pos.Na)))&quot;)
    Orbital: 10h
        principal quantum number: n = 10
        radial quantum number: n′ = 4 (number of nodes in radial wavefunction)
        orbital angular momentum of valence electron: ℓ = 5
    Grid created: exponential, Float64, Rmax = 360.0 a.u., Ntot = 550, h = 0.0181818, r0 = 0.0163447
    Def created for hydrogen 10h on exponential grid

    Z: WKB Ansatz for wavefunction (n &lt; Na=70))

plot_wavefunction(Z, 1:def.pos.Na, grid, def; reduced=true)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_wavefunction</code> is not included in the <code>CamiXon</code> package. <img src="assets/OUTSCH_H1_10h.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.adams_moulton_outward-Union{Tuple{T}, Tuple{Def{T}, Adams{T}}} where T&lt;:Real" href="#CamiXon.adams_moulton_outward-Union{Tuple{T}, Tuple{Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_outward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adams_moulton_outward(def::Def{T}, adams::Adams{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h4 id="Radial-integration-inward"><a class="docs-heading-anchor" href="#Radial-integration-inward">Radial integration - inward</a><a id="Radial-integration-inward-1"></a><a class="docs-heading-anchor-permalink" href="#Radial-integration-inward" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.INSCH-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real" href="#CamiXon.INSCH-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.INSCH</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">INSCH(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.adams_moulton_inward-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real" href="#CamiXon.adams_moulton_inward-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_inward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adams_moulton_inward(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h4 id="Radial-integration-boundary-condition-applied-and-convergence-test"><a class="docs-heading-anchor" href="#Radial-integration-boundary-condition-applied-and-convergence-test">Radial integration - boundary condition applied and convergence test</a><a id="Radial-integration-boundary-condition-applied-and-convergence-test-1"></a><a class="docs-heading-anchor-permalink" href="#Radial-integration-boundary-condition-applied-and-convergence-test" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.adams_moulton_normalized-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, T, Grid{T}, Def{T}}} where T&lt;:Real" href="#CamiXon.adams_moulton_normalized-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_normalized</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adams_moulton_normalized(Z::Vector{Complex{T}}, ΔQ::T, grid::Grid{T}, def::Def{T}) where T&lt;:Real</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.adams_moulton_patch-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}, Adams{T}}} where T&lt;:Real" href="#CamiXon.adams_moulton_patch-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_patch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adams_moulton_patch(Z::Vector{Complex{T}}, def::Def{T}, adams::Adams{T}) where T&lt;:Real</code></pre><p>Correct first 2k points of Z.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h4 id="Adams-Moulton-Master-procedures"><a class="docs-heading-anchor" href="#Adams-Moulton-Master-procedures">Adams-Moulton Master procedures</a><a id="Adams-Moulton-Master-procedures-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Moulton-Master-procedures" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.adams_moulton_prepare-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real" href="#CamiXon.adams_moulton_prepare-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_prepare</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adams_moulton_prepare(E::T, grid::Grid{T}, def::Def{T}, adams::Adams{T}) where T&lt;:Real</code></pre><p>Solves the Schrödinger equation for an atom defined by <code>def</code> for energy <code>E</code> on grid the <code>grid</code> with the Adams-Moulton method defined by <code>adams</code>. <code>E</code> is adjusted until the wavefunction has the correct number of <code>n′</code> nodes.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">Ecal, grid, def, adams = demo_hydrogen(n=1, ℓ=0);
    Def created for hydrogen 1s on exponential grid of 100 points

E = 1.5Ecal
msg, adams, init, Z = adams_moulton_prepare(E, grid, def, adams);
    Ecal = -0.5; E = -0.75; 0 nodes

plot_wavefunction(Z, 1:def.pos.N, grid, def; reduced=false)</code></pre><p>The plot is made using <code>CairomMakie</code>. Note the discontinuity in the derivative. NB.: <code>plot_wavefunction</code> is not included in the <code>CamiXon</code> package.</p><p><img src="assets/hydrogen-1s-prepared.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.adams_moulton_iterate-Union{Tuple{T}, Tuple{NTuple{4, T}, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real" href="#CamiXon.adams_moulton_iterate-Union{Tuple{T}, Tuple{NTuple{4, T}, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adams_moulton_iterate(init::NTuple{4,T}, grid::Grid{T}, def::Def{T}, adams::Adams{T}; imax=25, Δν=Value(1,&quot;kHz&quot;)) where T&lt;:Real</code></pre><p>Solves the Schrödinger equation for an atom defined by <code>def</code> for energy <code>E</code> on grid the <code>grid</code> with the Adams-Moulton method defined by <code>adams</code>; <code>E</code> is adjusted in an iteration procedure until convergence is reached within the convergence goal <code>Δν</code> is reached (limited to a maximum of <code>imax</code> iterations).</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">Ecal, grid, def, adams = demo_hydrogen(n=1, ℓ=0);
    Def created for hydrogen 1s on exponential grid of 100 points

E = 1.5Ecal;
msg1, adams, init, Z = adams_moulton_prepare(E, grid, def, adams);
println(&quot;Ecal = $Ecal; E = $(init[2]); $(def.pos.nodes) nodes&quot;)
    Ecal = -0.5; E = -0.75; 0 nodes

msg2, adams, init, Z = adams_moulton_iterate(init, grid, def, adams; Δν=Value(1,&quot;MHz&quot;), imax=25)
println(&quot;Ecal = $Ecal; E = $(init[2]); $(def.pos.nodes) nodes&quot;)
    Ecal = -0.5; E = -0.49999997841850014; 0 nodes

plot_wavefunction(Z, 1:def.pos.N, grid, def; reduced=false)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_wavefunction</code> is not included in the <code>CamiXon</code> package. <img src="assets/hydrogen-1s.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.adams_moulton_master-Tuple{Any, Any, Any}" href="#CamiXon.adams_moulton_master-Tuple{Any, Any, Any}"><code>CamiXon.adams_moulton_master</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adams_moulton_master(E, grid, def; Δν=Value(1,&quot;kHz&quot;), imax=25, msg=false)</code></pre><p>Solves the Schrödinger equation for an atom defined by <code>def</code> for energy <code>E</code> on grid the <code>grid</code> with the Adams-Moulton method defined by <code>adams</code>.</p><p><code>Δν</code>: convergence goal</p><p><code>imax</code>: maximum number of iterations</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; codata = castCodata(2022);
julia&gt; atom = castAtom(Z=1, A=1, Q=0; msg=false);
julia&gt; orbit = castOrbit(n=1, ℓ=0; msg=false);
julia&gt; grid = autoGrid(atom, orbit, Float64; Nboost=10, msg=false);
julia&gt; def = castDef(grid, atom, orbit, codata);
Def created for ¹H:1s on exponential grid of 1200 points

julia&gt; E = initE(def);
julia&gt; E, Z = adams_moulton_master(E, grid, def; Δν=Value(1,&quot;kHz&quot;), imax=25, msg=false);</code></pre><p>The plot is made using <code>CairoMakie</code>. NB.: <code>plot_wavefunction</code> is not included in the <code>CamiXon</code> package. <img src="assets/hydrogen-1s.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h2 id="Coulomb-integrals"><a class="docs-heading-anchor" href="#Coulomb-integrals">Coulomb integrals</a><a id="Coulomb-integrals-1"></a><a class="docs-heading-anchor-permalink" href="#Coulomb-integrals" title="Permalink"></a></h2><h3 id="Angular-integrals"><a class="docs-heading-anchor" href="#Angular-integrals">Angular integrals</a><a id="Angular-integrals-1"></a><a class="docs-heading-anchor-permalink" href="#Angular-integrals" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.a_direct-NTuple{5, Int64}" href="#CamiXon.a_direct-NTuple{5, Int64}"><code>CamiXon.a_direct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">a_direct(k::Int, l::Int, ml::Int, l′::Int, ml′::Int)</code></pre><p>Coulomb angular integral - direct part:</p><p class="math-container">\[a^{k}(lm_{l};l^{\prime}m_{l^{\prime}})=(-)^{m_{l}+m_{l^{\prime}}}
(2l+1)(2l^{\prime}+1)\left(\begin{array}{ccc}
l &amp; k &amp; l\\
0 &amp; 0 &amp; 0
\end{array}\right)\left(\begin{array}{ccc}
l &amp; k &amp; l\\
-m_{l} &amp; 0 &amp; m_{l}
\end{array}\right)\left(\begin{array}{ccc}
l^{\prime} &amp; k &amp; l^{\prime}\\
0 &amp; 0 &amp; 0
\end{array}\right)\left(\begin{array}{ccc}
l^{\prime} &amp; k &amp; l^{\prime}\\
-m_{l^{\prime}} &amp; 0 &amp; m_{l^{\prime}}
\end{array}\right)\]</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">a_direct(2,1,1,2,2)
    2//35

a_direct(6,3,2,3,-1)
    -250//20449</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.b_exchange-NTuple{5, Int64}" href="#CamiXon.b_exchange-NTuple{5, Int64}"><code>CamiXon.b_exchange</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">b_exchange(k::Int, l::Int, ml::Int, l′::Int, ml′::Int)</code></pre><p>Coulomb angular integral - exchange part:</p><p class="math-container">\[b^{k}(lm_{l};l^{\prime}m_{l^{\prime}})=(2l+1)(2l^{\prime}+1)
\left(\begin{array}{ccc}
l &amp; k &amp; l^{\prime}\\
0 &amp; 0 &amp; 0
\end{array}\right)^{2}\left(\begin{array}{ccc}
l &amp; k &amp; l^{\prime}\\
-m_{l} &amp; (m_{l}-m_{l^{\prime}}) &amp; m_{l^{\prime}}
\end{array}\right)^{2}\]</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">b_exchange(1,1,1,2,2)
    2//5

b_exchange(6,3,2,3,-1)
    1050//20449</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.UF-Union{Tuple{V}, Tuple{T}, Tuple{Int64, Vector{T}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}" href="#CamiXon.UF-Union{Tuple{V}, Tuple{T}, Tuple{Int64, Vector{T}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.UF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UF(k::Int, P::Vector{T}, grid::Grid{V}) where {T&lt;:Real, V&lt;:Real}</code></pre><p>Potential for <em>directe</em> screening,</p><p class="math-container">\[U_{F}^{k}(\rho)
=\frac{1}{\rho^{k+1}}\int_{0}^{\rho}\varrho^{k}
\left[\tilde{R}_{nl}(\varrho)\right]^{2}
\varrho^{2}d\varrho+\rho^{k}\int_{\rho}^{\infty}
\frac{1}{\varrho^{k+1}}
\left[\tilde{R}_{nl}(\varrho)\right]^{2}\varrho^{2}d\varrho.\]</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">atom = castAtom(Z=2, A=4, Q=0; msg=true)
orbit = castOrbit(n=1, ℓ=0; msg=true)
scr = nothing
grid = autoGrid(atom, orbit, Float64; Nboost=1, msg=true)
def = castDef(grid, atom, orbit, codata; scr)
E = initE(def1)
adams = castAdams(E, grid, def)
E, def, adams, Z = adams_moulton_master(E, grid, def, adams; Δν=Value(1,&quot;kHz&quot;), imax=50, msg=false);

P1 = real(Z)
UF0P1 = UF(0, P1, grid);
plot_function(scrUF0P1, 1:grid.N, grid; title=&quot;He4(1s,1s):  direct screening potential&quot;)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_function</code> is not included in the <code>CamiXon</code> package. <img src="assets/He41s-UF0.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.UG-Union{Tuple{V}, Tuple{T}, Tuple{Int64, Vector{T}, Vector{T}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}" href="#CamiXon.UG-Union{Tuple{V}, Tuple{T}, Tuple{Int64, Vector{T}, Vector{T}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.UG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UG(k::Int, P1::Vector{T}, P2::Vector{T}, grid::Grid{V}) where {T&lt;:Real, V&lt;:Real}</code></pre><p>Potential for <em>exchange</em> screening,</p><p class="math-container">\[U_{G}^{k}(\rho)
=\frac{1}{\rho^{k+1}}\int_{0}^{\rho}\varrho^{k}\tilde{R}_{nl}(\varrho)
\tilde{R}_{n^{\prime}l^{\prime}}(\varrho)\,
\varrho^{2}d\varrho+\rho^{k}\int_{\rho}^{\infty}
\frac{1}{\varrho^{k+1}}\tilde{R}_{nl}(\varrho)
\tilde{R}_{n^{\prime}l^{\prime}}(\varrho)\,\varrho^{2}d\varrho.\]</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">atom = castAtom(Z=2, A=4, Q=0; msg=true)
orbit1 = castOrbit(n=1, ℓ=0; msg=true)
orbit2 = castOrbit(n=2, ℓ=0; msg=true)
scr = nothing
grid = autoGrid(atom, [orbit1,orbit2], Float64; Nboost=1, msg=true)
def1 = castDef(grid, atom, orbit1, codata; scr)
E = initE(def1)
adams = castAdams(E, grid, def1)
E, def, adams, Z1 = adams_moulton_master(E, grid, def1, adams; Δν=Value(1,&quot;kHz&quot;), imax=50, msg=false);

def2 = castDef(grid, atom, orbit2, codata; scr)
E = initE(def2)
adams = castAdams(E, grid, def2)
E, def, adams, Z2 = adams_moulton_master(E, grid, def2, adams; Δν=Value(1,&quot;kHz&quot;), imax=50, msg=false);

P1 = real(Z1);
P2 = real(Z2);

UG0 = UG(0, P1, P2, grid);
plot_function(UG0, 1:grid.N, grid; title=&quot;He4(1s,2s):  exchange screening potential&quot;)</code></pre><p>The plot is made using <code>CairomMakie</code>. NB.: <code>plot_function</code> is not included in the <code>CamiXon</code> package. <img src="assets/He41s-UG0.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.step125-Tuple{Real}" href="#CamiXon.step125-Tuple{Real}"><code>CamiXon.step125</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">step125(x)</code></pre><p>Step used for deviding the number x in steps according to 1-2-5 scheme</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">step125.([5,10,21.3,50,100.1])
5-element Vector{Int64}:
  1
  2
  5
 10
 20</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.select125-Tuple{Any}" href="#CamiXon.select125-Tuple{Any}"><code>CamiXon.select125</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select125(x)</code></pre><p>Select elements of the collection x by index according to 1-2-5 scheme</p><p><strong>Examples:</strong></p><pre><code class="language- hljs">x = [1,2,4,6,8,10,13,16,18,20,40,60,80,100]
select125(x)
 [2, 6, 10, 16, 20, 60, 100]

x = string.(x)
select125(x)
 [&quot;2&quot;, &quot;6&quot;, &quot;10&quot;, &quot;16&quot;, &quot;20&quot;, &quot;60&quot;, &quot;100&quot;]

x = 1:100
select125(x)
 [20, 40, 60, 80, 100]</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.steps-Tuple{Vector{T} where T&lt;:Real}" href="#CamiXon.steps-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.steps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">steps(x)</code></pre><p>Heatmap range transformation for steplength specification vector x</p><p><strong>Examples:</strong></p><pre><code class="language- hljs">x = [4,2,6]
steps(x)
 [0, 4, 6, 12]</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.stepcenters-Tuple{Vector{T} where T&lt;:Real}" href="#CamiXon.stepcenters-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.stepcenters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stepcenters(x)</code></pre><p>Stepcenter positions for steplength specification vector x</p><p><strong>Examples:</strong></p><pre><code class="language- hljs">x = [4,2,6]
stepcenters(x)
 [2.0, 5.0, 9.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.stepedges-Tuple{Vector{T} where T&lt;:Real}" href="#CamiXon.stepedges-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.stepedges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stepedges(x)</code></pre><p>Stepedges for steplength specification vector x</p><p><strong>Examples:</strong></p><pre><code class="language- hljs">x = [4,2,6]
stepedges(x)
 [0, 4, 6, 12]</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.edges" href="#CamiXon.edges"><code>CamiXon.edges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">edges(px [, Δx[, x0]])</code></pre><p>Heatmap range transformation from pixel coordinates to physical coordinates, with pixelsize Δx and offset x0, both in physical units.</p><p><strong>Examples:</strong></p><pre><code class="language- hljs">px = 1:5
Δx = 2.5
x0 = 2.5
edges(px)
 [0.5, 1.5, 2.5, 3.5, 4.5]

edges(px, Δx)
 [1.25, 3.75, 6.25, 8.75, 11.25]

edges(px, Δx, x0)
 [-1.25, 1.25, 3.75, 6.25, 8.75]</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h2 id="Julia-tools"><a class="docs-heading-anchor" href="#Julia-tools">Julia tools</a><a id="Julia-tools-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-tools" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.primitivetype-Tuple{Type}" href="#CamiXon.primitivetype-Tuple{Type}"><code>CamiXon.primitivetype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primitivetype(T::Type)</code></pre><p>The primitive type of a Type</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; T = Complex{Float16}};
julia&gt; primitivetype(T)
Float16

julia&gt; T = String
julia&gt; primitivetype(T)
Char</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.lc_primitivetype-Tuple{Any}" href="#CamiXon.lc_primitivetype-Tuple{Any}"><code>CamiXon.lc_primitivetype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lc_primitivetype(o::Any)</code></pre><p>Lowest comon primitive type of Any Type</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; o = ([1//2, 1//3]; (1//4, 1//1, 1//6));
julia&gt; lc_primitivetype(o)
Int64</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.lc_eltype-Tuple{Any}" href="#CamiXon.lc_eltype-Tuple{Any}"><code>CamiXon.lc_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lc_eltype(o)</code></pre><p>Lowest common eltype of a collection.</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; o = ([1//2, 1//3]; (1//4, 1//1, 1//6));
julia&gt; lc_eltype(o)
Rational{Int64}

julia&gt; o = ([1//2, 1//3]; (1//4, big(1)//big(5), 1//6));
julia&gt; lc_eltype(o)
Rational

julia&gt; o = ([1//2, 1//3]; (1//4, [big(1)//big(5)], 1//6));
julia&gt; lc_eltype(o)
Any

julia&gt; o = ([1/2, 1/3]; (1/4, 1/1, 1/6));
julia&gt; lc_eltype(o)
Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.bigconvert-Tuple{Any}" href="#CamiXon.bigconvert-Tuple{Any}"><code>CamiXon.bigconvert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bigconvert(o)</code></pre><p>Convert IntBased types to <code>BigIntBased</code> types for <code>n &gt; nc</code> in accordance with <code>dictBigConversion</code>.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; o = [[1//1, 1//2, 1//3],[1//1, 1//2, 1//3]]
2-element Vector{Vector{Rational{Int64}}}:
 [1//1, 1//2, 1//3]
 [1//1, 1//2, 1//3]

julia&gt; bigconvert(o)
2-element Vector{Vector{Rational{Int64}}}:
 [1//1, 1//2, 1//3]
 [1//1, 1//2, 1//3]</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.conditionalType-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Integer" href="#CamiXon.conditionalType-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Integer"><code>CamiXon.conditionalType</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conditionalType(n::T, nc::T [; msg=true]) where T&lt;:Integer</code></pre><p>Convert type <code>T</code> to <code>BigInt</code> for <code>n &gt; nc</code>.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; conditionalType(46, 46)
Int64

julia&gt; conditionalType(47, 46)
BigInt</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.find_all-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T" href="#CamiXon.find_all-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_all(A [,a...]; count=false)</code></pre><p>A: string/array of elements of the same type</p><p>default   : Array containing the index (indices) of selected elements of A (default: all elements)</p><p>count=true: The number of indices found for selected elements of A (default: all elements)</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">A = [:📑,:📌,:📢,:📌,:📞]
B = [1,2,3,2,5]
str = &quot;aβcβd&quot;;
find_all(A) == find_all(B) == find_all(str)
true

find_all(A,:📌)
1-element Array{Array{Int64,1},1}:
 [2, 4]

find_all(str)
4-element Array{Array{Int64,1},1}:
 [1]
 [2, 4]
 [3]
 [5]

find_all(A; count=true)
4-element Array{Int64,1}:
 1
 2
 1
 1

str = &quot;📑📌📢📌📞&quot;
find_all(str,&#39;📌&#39;)
1-element Array{Array{Int64,1},1}:
 [2, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.find_first-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T" href="#CamiXon.find_first-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_first</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_first(A [,a...]; dict=false)</code></pre><p>The first index of selected Array element</p><p>A: string/array of elements of the same type</p><p>default  : Array containing the first index (indices) of selected elements of A (default: all elements)</p><p>dict=true: Dict for the first index (indices) of selected elements of A (default: all elements)</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">A = [:📑,:📌,:📢,:📌,:📞]
B = [1,2,3,2,5]
str = &quot;aβcβd&quot;;

find_first(A) == find_first(B) == find_first(str)
true

find_first(A,:📌)
1-element Array{Array{Int64,1},1}:
 2

find_last(A,:📌; dict=true)
1-element Array{Pair{Symbol,Int64},1}:
 :📌 =&gt; 2

find_last(A; dict=true)
4-element Array{Pair{Symbol,Int64},1}:
 :📑 =&gt; 1
 :📌 =&gt; 2
 :📢 =&gt; 3
 :📞 =&gt; 5

find_first(str)
4-element Array{Int64,1}:
 1
 2
 3
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.find_last-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T" href="#CamiXon.find_last-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_last</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_last(A [,a...]; dict=false)</code></pre><p>The last index of selected Array element</p><p>A: string/array of elements of the same type</p><p>default  : Array containing the lasst index (indices) of selected elements of A (default: all elements)</p><p>dict=true: Dict for the lasst index (indices) of selected elements of A (default: all elements)</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">A = [:📑,:📌,:📢,:📌,:📞]
B = [1,2,3,2,5]
str = &quot;aβcβd&quot;;
find_last(A) == find_first(B) == find_first(str)
true

find_last(A,:📌)
1-element Array{Array{Int64,1},1}:
 4

find_last(A,:📌; dict=true)
1-element Array{Pair{Symbol,Int64},1}:
 :📌 =&gt; 4

find_last(A; dict=true)
4-element Array{Pair{Symbol,Int64},1}:
 :📑 =&gt; 1
 :📌 =&gt; 4
 :📢 =&gt; 3
 :📞 =&gt; 5

find_last(str)
4-element Array{Int64,1}:
 1
 4
 3
 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h2 id="Finite-difference-methods"><a class="docs-heading-anchor" href="#Finite-difference-methods">Finite-difference methods</a><a id="Finite-difference-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-difference-methods" title="Permalink"></a></h2><h3 id="Finite-differences"><a class="docs-heading-anchor" href="#Finite-differences">Finite differences</a><a id="Finite-differences-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-differences" title="Permalink"></a></h3><p>Consider the analytical function <span>$f$</span> tabulated in <em>forward order</em>   (growing index) at <span>$n$</span> positions on a <em>uniform grid</em>.</p><p><strong>Forward difference notation</strong></p><p>In <em>forward difference</em> notation, the <em>finite difference</em> of two adjacent values on the grid is defined as</p><p class="math-container">\[Δ f[n] = f[n+1]-f[n],\]</p><p>where <span>$Δ$</span> is the forward difference operator. By a formal inversion   procedure we find</p><p class="math-container">\[f[n-1]=(1+Δ)^{-1}f[n]=(1-Δ+Δ^2-Δ^3+⋯)f[n],\]</p><p>where <span>$Δ^k$</span> is the  <span>$k^{th}$</span>-<em>order forward difference</em> defined as a <em>weighted sum</em> over the function values <span>$f[n:n+k]$</span> (involving <span>$k+1$</span> points),</p><p class="math-container">\[Δ^k f[n] = c_{k}^kf[n] + c_{k-1}^kf[n+1] + ⋯  + f[n+k]
= \sum_{j=0}^{k} c_{k-j}^k f[n+j].\]</p><p>The <span>$k+1$</span> coefficients</p><p class="math-container">\[c_{k-j}^{k}=(-1)^{k-j}\binom{k}{j}\]</p><p>are the <em>summation weights</em> (short: <em>weights</em>) which define the summation.</p><p><strong>Backward difference notation</strong></p><p>In <em>backward difference</em> notation, the <em>finite difference</em> of two adjacent values on the grid is defined as</p><p class="math-container">\[∇ f[n] = f[n]-f[n-1],\]</p><p>where <span>$∇$</span> is the backward difference operator.  By a formal inversion   procedure we find</p><p class="math-container">\[f[n+1]=(1-∇)^{-1}f[n]=(1+∇+∇^2+∇^3+⋯)f[n],\]</p><p>where <span>$∇^k$</span> is the  <span>$k^{th}$</span>-<em>order backward difference</em> defined as a <em>weighted sum</em> over the function values tabulated in backward order, <span>$f[n:-1:n-k]$</span> (involving <span>$k+1$</span> points),</p><p class="math-container">\[∇^k f[n] = f[n] + c_1^kf[n-1] + ⋯ + c_k^kf[n-k]
= \sum_{j=0}^{k} c_j^kf[n-j],\]</p><p>where the <span>$k+1$</span> coefficients</p><p class="math-container">\[c_{j}^{k}=(-1)^{j}\binom{k}{j}\]</p><p>are the <em>summation weights</em> (short: <em>weights</em>) which define the summation. Note the special cases <span>$c_{0}^{k}≡1$</span>, <span>$c_{k}^{k}≡(-1)^{k}$</span> and the symmetry relation</p><p class="math-container">\[c_{k-j}^k=(-1)^k c_j^k.\]</p><p>Coefficients:  </p><p><a href="#CamiXon.fdiff_weight-Tuple{Int64, Int64}"><code>fdiff_weight(k,j)</code></a> <span>$→ c_j^k=(-1)^j\binom{k}{j}$</span></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.isforward-Tuple{Any}" href="#CamiXon.isforward-Tuple{Any}"><code>CamiXon.isforward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function isforward(val)</code></pre><p>Boolean status of <code>val</code>, with options: <code>fwd</code> (forward) and <code>bwd</code> (backward).</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia? isforward(fwd)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.isregular-Tuple{Any}" href="#CamiXon.isregular-Tuple{Any}"><code>CamiXon.isregular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function isregular(val)</code></pre><p>Boolean status of <code>val</code>, with options: <code>reg</code> (regular) and <code>rev</code> (reversed).</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">isregular(reg)
  true</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.fdiff_weight-Tuple{Int64, Int64}" href="#CamiXon.fdiff_weight-Tuple{Int64, Int64}"><code>CamiXon.fdiff_weight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fdiff_weight(k::Int, j::Int)</code></pre><p>Finite difference weight coefficient,</p><p class="math-container">\[c_{j}^{k}=(-1)^{k+j}\binom{k}{j}.\]</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">c(k,j) = fdiff_weight(k,j)

[[c(k,j) for j=0:k] for k=0:3] == [[1], [1, -1], [1, -2, 1], [1, -3, 3, -1]]
  true

[[c(k,k-j) for j=0:k] for k=0:3] == [[1], [-1, 1], [1, -2, 1], [-1, 3, -3, 1]]
  true</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h3 id="Finite-difference-expansions"><a class="docs-heading-anchor" href="#Finite-difference-expansions">Finite difference expansions</a><a id="Finite-difference-expansions-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-difference-expansions" title="Permalink"></a></h3><p>Finite-difference calculus builds on the <em>finite-difference expansion</em>.</p><p><strong>Forward difference notation</strong></p><p>In terms of forward differences the expansion takes the form</p><p class="math-container">\[\sum_{p=0}^{\infty}α_{p}Δ^{p}f[n]
=\sum_{p=0}^{k}α_{p}Δ^{p}f[n]+⋯.\]</p><p>A finite-difference expansion truncated at order <span>$k$</span> is defined by <span>$k+1$</span> <em>finite-difference expansion coefficients</em>, represented by the vector <span>$α = [α_{0},⋯\ α_{k}]$</span>. It takes some bookkeeping to rewrite the expansion as a <em>weighted sum</em> over the <span>$k+1$</span> <em>function values in forward tabulated form</em> <span>$f[n:n+k]$</span>. Substituting the finite difference expression for <span>$Δ^k$</span>, we obtain</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n]
=\sum_{p=0}^{k}α_{p}\sum_{j=0}^{p}c_{p-j}^{p}f[n+j]
=\sum_{j=0}^{k}\sum_{p=j}^{k}α_{p}c_{p-j}^{p}f[n+j]
=\sum_{j=0}^{k}F_{j}^{k}f[n+j],\]</p><p>where the weighted summation is defined by the <em>weights</em></p><p class="math-container">\[F_{j}^{k}=\sum_{p=j}^{k}α_{p}c_{p-j}^{p}
=\sum_{p=j}^{k}(-1)^{p+j}\binom{p}{j}α_{p},\]</p><p>with <span>$j=0,⋯\ k$</span>. In inner product form the expansion becomes</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n]
=\sum_{j=0}^{k}F_{j}^{k}f[n+j]
=F^{k} \cdot f[n:n+k],\]</p><p>where <span>$F^k  ≡ [F_0^k,⋯\ F_k^k]$</span>.</p><p class="math-container">\[f[n:n+k] = \left[\begin{array}{c}
f[n]\\
\vdots\\
f[n+k]
\end{array}\right].\]</p><p>Coefficients:</p><p><a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(coeffs, fwd, reg)</code></a> <span>$→ F^k ≡ [F_0^k,⋯\ F_k^k]$</span>,</p><p>where the <code>coeffs</code> <span>$α ≡ [α_0,⋯\ α_k]$</span> are user supplied to define the expansion.</p><p><strong>Backward difference notation</strong></p><p>In terms of backward differences the expansion takes the form</p><p class="math-container">\[\sum_{p=0}^{\infty}β_{p}∇^{p}f[n]=\sum_{p=0}^{k}β_{p}∇^{p}f[n]+⋯.\]</p><p>In this case the <span>$k^{th}$</span>- order <em>finite-difference expansion</em> is defined by the vector <span>$β = [β_{0},⋯\ β_{k}]$</span>. The expansion can written as <em>weighted sum</em> over the <span>$k+1$</span> <em>function values in backward tabulated form</em> <span>$f[n:-1:n-k]$</span>. Substituting the finite difference expression for <span>$∇^k$</span>, we obtain</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n]
=\sum_{p=0}^{k}β_{p}\sum_{j=0}^{p}c_{j}^{p}f[n-j]
=\sum_{j=0}^{k}\sum_{p=j}^{k}β_{p}c_{j}^{p}f[n-j]
=\sum_{j=0}^{k}B_{j}^{k}f[n-j],\]</p><p>where the <em>weights</em> are given by</p><p class="math-container">\[B_{j}^{k}=\sum_{p=j}^{k}β_{p}c_{j}^{p}
=\sum_{p=j}^{k}(-1)^{j}\binom{p}{j}β_{p},\]</p><p>with <span>$j=0,⋯\ k$</span>. In inner product form the expansion becomes</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n]
=\sum_{j=0}^k B_j^k f[n-j]
=\bar{B}^k \cdot f[n-k:n],\]</p><p>where the <em>weights vector</em> <span>$\bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span> contains the weights in backward order.</p><p>In general there is <em>no simple symmetry relation</em> between <span>$B^k$</span> and <span>$F^k$</span>.</p><p>Coefficients:</p><p><a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(coeffs, bwd, rev)</code></a> <span>$→ \bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span>,</p><p>where the <code>coeffs</code>  <span>$β ≡ [β_0,⋯\ β_k]$</span> are user supplied to define the expansion.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.fdiff_expansion_weights" href="#CamiXon.fdiff_expansion_weights"><code>CamiXon.fdiff_expansion_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fdiff_expansion_weights(coeffs[, notation=bwd[, ordering=rev]])</code></pre><p>Expansion weights corresponding to the expansion coefficients <code>coeffs</code> of a finite difference expansion.</p><p><strong>Forward difference notation</strong> (<code>notation = fwd</code>)</p><p>Weight vector <span>$F^k ≡ [F_k^k,⋯\ F_0^k]$</span> corresponding to the expansion coefficients <span>$α ≡ [α_0^k,⋯\ α_k^k]$</span> of the <span>$k^{th}$</span>-order <em>forward-difference</em> expansion,</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n]
=\sum_{j=0}^{k}F_{j}^{k}f[n+j]
=F^{k} \cdot f[n:n+k],\]</p><p>where <span>$f[n:n+k]$</span> are elements of the analytic function <span>$f$</span> tabulated in <em>forward</em> order.</p><p><a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(α, fwd, reg)</code></a> <span>$→ F^k ≡ [F_0^k,⋯\ F_k^k]$</span>,</p><p>where <span>$α ≡ [α_0,⋯\ α_k]$</span> has to be supplied in combination with <code>fwd</code> to indicate that the weights must be evaluated in forward-difference notation.</p><p><strong>Backward difference notation</strong> (<code>notation = bwd</code>)</p><p>Weight vector <span>$\bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span> corresponding to the expansion coefficients <span>$β ≡ [β_0,⋯\ β_k]$</span> of the <span>$k^{th}$</span>-order <em>backward-difference</em> expansion,</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n]
=\sum_{j=0}^{k}B_{j}^kf[n-j]
=\bar{B}^k \cdot f[n-k:n].\]</p><p>where <span>$f[n-k:n]$</span> are elements of the analytic function <span>$f$</span> tabulated in <em>forward</em> order.</p><p><a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, rev)</code></a> <span>$→ \bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span>,</p><p>where <span>$β ≡ [β_0,⋯\ β_k]$</span> has to be supplied in combination with <code>bwd</code> to indicate that the weights must be evaluated in backward-difference notation.</p><p><strong>Example:</strong></p><p>Consider the expansions,</p><p class="math-container">\[f[n-1]=(1+Δ)^{-1}f[n]=(1-Δ+Δ^2-Δ^3+⋯)f[n].\]</p><p class="math-container">\[f[n+1]=(1-∇)^{-1}f[n]=(1+∇+∇^2+∇^3+⋯)f[n],\]</p><pre><code class="nohighlight hljs">α = [1,-1,1,-1,1]
β = [1,1,1,1,1]
Fk = fdiff_expansion_weights(α, fwd, reg); println(&quot;Fk = $(Fk)&quot;)
  Fk = [5, -10, 10, -5, 1]

Bk = fdiff_expansion_weights(β, bwd, reg); println(&quot;Bk = $(Bk)&quot;)
  Bk = [5, -10, 10, -5, 1]

revFk = fdiff_expansion_weights(α, fwd, rev); println(&quot;revFk = $(revFk)&quot;)
  revFk = [1, -5, 10, -10, 5]

revBk = fdiff_expansion_weights(β, bwd, rev); println(&quot;revBk = $(revBk)&quot;)
  revBk = [1, -5, 10, -10, 5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.fdiff_expansion" href="#CamiXon.fdiff_expansion"><code>CamiXon.fdiff_expansion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fdiff_expansion(coeffs, f[, notation=bwd])</code></pre><p>Finite difference expansion of the analytical function f(x) tabulated in <em>forward order</em> (growing index) at <span>$k+1$</span> positions on a uniform grid. The expansion coefficients are specified by the vector <code>coeffs</code>. By default <code>coeffs</code> are assumed to be in backward-difference notation (<code>bwd</code>). For <code>coeffs</code> in forward-difference notation the third argument must be <code>fwd</code>.</p><p><strong>Forward difference notation</strong> (<code>notation = fwd</code>)</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n] = F^{k} \cdot f[n:n+k],\]</p><p>where <span>$f[n:n+k]$</span> are elements of the analytical function <span>$f$</span> (tabulated in <em>forward</em> order) and <span>$α ≡ [α_0,⋯\ α_k]$</span> is the vector <code>coeffs</code>, which has to be supplied to define the forward-difference expansion. The corresponding weights vector <span>$F^{k}$</span> is internally generated.</p><p><strong>Backward difference notation</strong> (<code>notation = bwd</code>)</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n] = \bar{B}^k \cdot f[n-k:n].\]</p><p>where <span>$f[n-k:n]$</span> are elements of the analytical function <span>$f$</span> (tabulated in <em>forward</em> order) and <span>$β ≡ [β_0,⋯\ β_k]$</span> is the vector <code>coeffs</code>, which has to be supplied to define the backward-difference expansion. The corresponding weights vector <span>$\bar{B}^k$</span> is internally generated.</p><p><strong>Examples:</strong></p><p>Consider the function <span>$f(x)=x^2$</span> and the expansions,</p><p class="math-container">\[f(x-1)=(1+Δ)^{-1}=(1-Δ+Δ^2-Δ^3+⋯)f(x).\]</p><p class="math-container">\[f(x+1)=(1-∇)^{-1}=(1+∇+∇^2+∇^3+⋯)f(x),\]</p><p>To fourth order <code>(k=4)</code> the forward- and backward-difference coefficient vectors are <code>α=[1,-1,1,-1,1]</code> and <code>β=[1,1,1,1,1]</code>, respectively. We tabulate the function at <span>$k+1$</span> points, <code>f=[1,4,9,16,25]</code>.</p><pre><code class="nohighlight hljs">α = [1,-1,1,-1,1]
Fk = fdiff_expansion_weights(α, fwd, reg); println(&quot;Fk = $(Fk)&quot;)
  Fk = [5, -10, 10, -5, 1]

β = [1,1,1,1,1]
revBk = fdiff_expansion_weights(β, bwd, rev); println(&quot;revBk = $(revBk)&quot;)
  revBk = [1, -5, 10, -10, 5]

f = [1,4,9,16,25]
o = fdiff_expansion(α, f, fwd); println(&quot;f[0] = $(o)&quot;)
  f[0] = 0

fdiff_expansion(α, f, fwd) == Fk ⋅ f == fdiff_interpolation(f, 0)
  true

o = fdiff_expansion(β, f, bwd); println(&quot;f[6] = $(o)&quot;)
  f[6] = 36

fdiff_expansion(β, f, bwd) == revBk ⋅ f == fdiff_interpolation(f, length(f)+1)
  true</code></pre><p>In these cases the results are exact because the function is quadratic and the expansion is third order (based on the polynomial of <span>$k^{th}$</span> degree running through the <span>$k+1$</span> points of the tabulated function). Note the relation with <a href="#CamiXon.fdiff_interpolation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}"><code>fdiff_interpolation(f, v, k=3)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h3 id="Lagrange-polynomial-interpolation/extrapolation"><a class="docs-heading-anchor" href="#Lagrange-polynomial-interpolation/extrapolation">Lagrange-polynomial interpolation/extrapolation</a><a id="Lagrange-polynomial-interpolation/extrapolation-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrange-polynomial-interpolation/extrapolation" title="Permalink"></a></h3><p>The Lagrange polynomial of degree k on a uniform grid is the polynomial running through k+1 subsequent points on the grid. We derive expressions for interpolation/extrapolation in both forward- and backward-difference notation. Beware that Lagrange interpolation becomes inaccurate if the tabulated function cannot be approximated by a polynomial of degree k.</p><p><strong>Forward difference notation</strong></p><p>Starting from the relation</p><p class="math-container">\[f[n]=(1+Δ)f[n+1],\]</p><p>we obtain by formal operator inversion</p><p class="math-container">\[f[n+1] = (1 + Δ)^{-1} f[n] \equiv \sum_{p=0}^{\infty}(-1)^p Δ^p f[n],\]</p><p class="math-container">\[f[n+2] = (1 + Δ)^{-2} f[n] \equiv \sum_{p=0}^{\infty}(-1)^p pΔ^p f[n],\]</p><p class="math-container">\[\vdots\]</p><p>where <span>$k$</span> is called the order of the expansion and <span>$n$</span> is the reference index. For interpolation position <span>$n-σ$</span> (where σ may be <em>real</em> valued in index units) these expansions can be generalized to the form of <em>lagrangian interpolation</em>,</p><p class="math-container">\[f[n-σ] = (1 + Δ)^{-σ} f[n] \equiv \sum_{p=0}^{\infty} α_p(σ) Δ^p f[n],\]</p><p>where</p><p class="math-container">\[α_p(σ) ≡ (-1)^p(σ)_p/p!\]</p><p>is the <span>$p^{th}$</span>-order <em>finite-difference expansion coefficient</em> for lagrangian lagrangian interpolation over the interval <span>$-k ≤σ ≤0\ \ (n \le n-σ \le n+k)$</span>,</p><p class="math-container">\[(σ)_{p}=\begin{cases}
1 &amp; p=0\\
σ(σ+1)(σ+2)\cdots(σ+p-1) &amp; p&gt;0
\end{cases}\]</p><p>being the Pochhammer symbol <code>CamiMath.pochhammer</code>. For <span>$σ$</span> outside  the interpolation interval the method corresponds to <em>extrapolation</em> along the Lagrange polynomial. Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain  </p><p class="math-container">\[f[n-σ] =\sum_{p=0}^{k}α_p(σ)Δ^pf[n]
=\sum_{j=0}^{k}F_j^k(σ)f[n+j]
=F^k(σ) \cdot f[n:n+k],\]</p><p>where the <span>$k+1$</span> <em>weights</em></p><p class="math-container">\[F_j^k(σ)= \sum_{p=j}^{k} (-1)^k α_p(σ) c_j^p
=\sum_{p=j}^{k} (-1)^j \binom{p}{j}(σ)_p/p!\]</p><p>are the <em>lagrangian interpolation weights</em> corresponding to the point <span>$f[n-σ]$</span>.</p><p>Symmetry relation:</p><p class="math-container">\[\bar{F}^k(-k-σ) = F^k(σ)\]</p><p>Weight functions:</p><p><a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(coeffs, fwd, reg)</code></a> <span>$→ F^k(σ) ≡ [F^k_0(σ),⋯\ F^k_k]$</span>,</p><p>where the vector</p><p><code>coeffs =</code><a href="#CamiXon.fdiff_interpolation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_coeffs(σ, k, fwd)</code></a> <span>$→ α(σ) ≡ [α_0(σ),⋯\ α_k(σ)]$</span>  contains the coefficients of the lagrangian-interpolation expansion.</p><p><strong>Backward difference notation</strong></p><p>Starting from the relation</p><p class="math-container">\[f[n]=(1-∇)f[n+1].\]</p><p>we obtain by formal operator inversion</p><p class="math-container">\[f[n+1] = (1 - ∇)^{-1} f[n] \equiv \sum_{p=0}^{\infty}∇^p f[n],\]</p><p class="math-container">\[f[n+2] = (1 - ∇)^{-2} f[n] \equiv \sum_{p=0}^{\infty}p∇^p f[n],\]</p><p class="math-container">\[\vdots\]</p><p>where <span>$k$</span> is called the order of the expansion and <span>$n$</span> is the reference index. For interpolation position <span>$n-σ$</span> (where σ may be <em>real</em> valued in index units) these expansions can be generalized to the form of <em>lagrangian interpolation</em>,</p><p class="math-container">\[f[n+σ] = (1 - ∇)^{-σ} f[n] \equiv \sum_{p=0}^{\infty} β_p(σ) ∇^p f[n],\]</p><p>where</p><p class="math-container">\[β_p(σ) ≡ (σ)_p/p! = (-1)^p α_p(σ)\]</p><p>is the <span>$p^{th}$</span>-order <em>finite-difference expansion coefficient</em> for lagrangian interpolation over the interval <span>$-k ≤σ ≤0\ \ (n-k \le n+σ \le n)$</span>, with</p><p class="math-container">\[(σ)_{p}=\begin{cases}
1 &amp; p=0\\
σ(σ+1)(σ+2)\cdots(σ+p-1) &amp; p&gt;0
\end{cases}\]</p><p>being the Pochhammer symbol <code>CamiMath.pochhammer</code>. For <span>$σ$</span> outside  the interpolation interval the method corresponds to <em>extrapolation</em> along the Lagrange polynomial. Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain</p><p class="math-container">\[f[n+σ] =\sum_{p=0}^{k}β_p(σ)∇^pf[n]
= \sum_{j=0}^{k}B^k_j(σ)f[n-j]
= \bar{B}^k(σ) ⋅ f[n-k:n],\]</p><p>where the <span>$k+1$</span> <em>weights</em></p><p class="math-container">\[B^k_j(σ)= \sum_{p=j}^{k} β_p(σ) c_j^p\]</p><p>are the corresponding <em>lagrangian interpolation weights</em>.  </p><p>Symmetry relations:</p><p class="math-container">\[B^k(σ) = F^k(σ) = \bar{B}^k(-k-σ)\]</p><p class="math-container">\[\bar{B}^k(σ) = B^k(-k-σ)\]</p><p>Weight function:</p><p><a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(coeffs, bwd, rev)</code></a> <span>$→ \bar{B}^k(σ) ≡ [B_k^k(σ),⋯\ B_0^k(σ)]$</span>,</p><p>where the vector</p><p><code>coeffs =</code><a href="#CamiXon.fdiff_interpolation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_coeffs(σ, k=3, notation=bwd)</code></a> <span>$→ β(σ) ≡ [β_0(σ),⋯\ β_k(σ)]$</span> contains the coefficients of the lagrangian-interpolation expansion.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.fdiff_interpolation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real" href="#CamiXon.fdiff_interpolation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>CamiXon.fdiff_interpolation_expansion_coeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fdiff_interpolation_expansion_coeffs(ξ::T [, k=3 [, notation=bwd]]) where T&lt;:Real</code></pre><p>Finite-difference expansion coefficient vector defining the <span>$k^{th}$</span>-order (default <em>third</em> order) Lagrange-polynomial interpolation of a tabulated analytic function <span>$f[n]$</span> at offset <span>$ξ$</span> with respect to index position <span>$n$</span>, which is positive for increasing index and negative for decreasing index.</p><p><strong>Forward difference notation</strong> (<code>notation = fwd</code>)</p><p>In this case we consider the tabulated interval <span>$f[n:n+k]$</span>. The interpolated value <span>$f[n+ξ]$</span> is given by the forward-difference expansion</p><p class="math-container">\[f[n+ξ] = \sum_{p=0}^k α_p(-ξ) Δ^p f[n] + ⋯,\]</p><p>where the expansion coefficients are given by</p><p><a href="#CamiXon.fdiff_interpolation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_coeffs(ξ, k, fwd)</code></a> <span>$→ α(-ξ) ≡ [α_0(-ξ),⋯\ α_k(-ξ)]$</span>. In this notation the range <span>$0\leq ξ\leq k$</span> corresponds to interpolation and the ranges <span>$ξ&lt;0$</span> and <span>$ξ&gt;k$</span> to extrapolation.</p><p><strong>Backward difference notation</strong> (<code>notation = bwd</code>)</p><p>In this case we consider the tabulated interval <span>$f[n-k:n]$</span>. The interpolated value <span>$f[n+ξ]$</span> is given by the backward-difference expansion</p><p class="math-container">\[f[n+ξ] = \sum_{p=0}^k β_p(ξ) ∇^p f[n] + ⋯,\]</p><p>where the expansion coefficients are given by</p><p><a href="#CamiXon.fdiff_interpolation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_coeffs(ξ, k, bwd)</code></a> <span>$→ β(ξ) ≡ [β_0(ξ),⋯\ β_k(ξ)]$</span>. In this notation the range <span>$-k\leq ξ\leq0$</span> corresponds to interpolation and the ranges <span>$ξ&lt;-k$</span> and <span>$ξ&gt;0$</span> to extrapolation.</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">k = 5
ξ = -1
α = fdiff_interpolation_expansion_coeffs(ξ, k, fwd); println(&quot;α = $α&quot;)
β = fdiff_interpolation_expansion_coeffs(ξ, k, bwd); println(&quot;β = $β&quot;)
  α = [1, 1, 0, 0, 0, 0]
  β = [1, 1, 1, 1, 1, 1]

ξ = 0
α = fdiff_interpolation_expansion_coeffs(ξ, k, fwd); println(&quot;α = $α&quot;)
β = fdiff_interpolation_expansion_coeffs(ξ, k, bwd); println(&quot;β = $β&quot;)
  α = [1, 0, 0, 0, 0, 0]
  β = [1, 0, 0, 0, 0, 0]

ξ = 1
α = fdiff_interpolation_expansion_coeffs(ξ, k, fwd); println(&quot;α = $α&quot;)
β = fdiff_interpolation_expansion_coeffs(ξ, k, bwd); println(&quot;β = $β&quot;)
  α = [1, -1, 1, -1, 1, -1]
  β = [1, -1, 0, 0, 0, 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.fdiff_interpolation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}" href="#CamiXon.fdiff_interpolation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.fdiff_interpolation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fdiff_interpolation(f::Vector{T}, v::V; k=3) where {T&lt;:Real, V&lt;:Real}</code></pre><p>Finite difference lagrangian interpolation (by default <em>third</em> order) at real position v (in index units) with respect to the elements of the uniformly tabulated analytic function <code>f[1:N]</code>. The interpolation points lie on a Lagrange polynomial of degree <span>$k$</span> (by default <em>third</em> degree) running through <span>$k+1$</span> subsequenct points of the tabulated function. Outside the tabulated range, the method represents extrapolation on the lagrangian polynomial defined by the first/last <span>$k+1$</span> tabulated points.</p><p>Beware that the interpolation becomes inaccurate if the tabulated function cannot be approximated by a polynomial of degree <span>$k$</span>.</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">f = [1,2,3,4,5,6,7]
[fdiff_interpolation(f, v; k=3) for v=1:0.5:7]
  [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0]

f = [1,4,9,16,25,36,49]
[fdiff_interpolation(f, v; k=3) for v=1:0.5:7]
 [1.0, 2.25, 4.0, 6.25, 9.0, 12.25, 16.0, 20.25, 25.0, 30.25, 36.0, 42.25, 49.0]

 f = [x^3 for x=-4:2]
 f1(v) = fdiff_interpolation(f, v; k=1)
 f2(v) = fdiff_interpolation(f, v; k=2)
 f3(v) = fdiff_interpolation(f, v; k=3)
 [[f1(v),f2(v),f3(v)] for v=1:0.5:9]
   [[-64.0, -64.0, -64.0], [-45.5, -43.25, -42.875], [-27.0, -27.0, -27.0],
   [-17.5, -16.0, -15.625], [-8.0, -8.0, -8.0], [-4.5, -3.75, -3.375],
   [-1.0, -1.0, -1.0], [-0.5, -0.5, -0.125], [0.0, 0.0, 0.0],
   [0.5, -0.25, 0.125], [1.0, 1.0, 1.0], [4.5, 3.75, 3.375], [8.0, 8.0, 8.0],
   [11.5, 13.75, 15.625], [15.0, 21.0, 27.0], [18.5, 29.75, 42.875],
   [22.0, 40.0, 64.0]]</code></pre><p>The result for f3(v) is exact because the function is cubic and the expansion is third order - see Figure below. The tabulated function is given by the black points. The interpolation and extrapolation points are red.</p><p><img src="assets/lagrangian_interpolation.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h3 id="Lagrangian-differentiation"><a class="docs-heading-anchor" href="#Lagrangian-differentiation">Lagrangian differentiation</a><a id="Lagrangian-differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrangian-differentiation" title="Permalink"></a></h3><p>To derive the <em>lagrangian differentiation</em> formulas we formally differentiate</p><p class="math-container">\[f[n+x] = (1 - ∇)^{-x} f[n]\]</p><p>with respect to <span>$x$</span>.</p><p class="math-container">\[\frac{df}{dx}[n+x]
=-ln(1-∇)\ (1-∇)^{-x}f[n]
=\sum_{q=1}^{k}\tfrac{1}{q}∇^{q}\sum_{p=0}^{k}l_{p}(x)∇^{p}f[n]+⋯.\]</p><p>Rewriting the r.h.s. as a single summation in powers of <span>$∇$</span> for given values of <span>$n$</span> and <span>$x$</span> we obtain an expression of the form</p><p class="math-container">\[\frac{df}{dx}[n+x]=\sum_{p=1}^{k}β_p(x)∇^{p}f[n]+⋯,\]</p><p>where <span>$β_p(x)$</span> represents the <em>finite-difference expansion coefficients</em> for <em>lagrangian differentiation</em> at position <span>$n+x$</span>. These coefficients are determined numerically by polynomial multiplication. As the expansion algorith requires the presentce of a <span>$β_0(x)$</span> coefficient we add a (vanishing) <span>$p=0$</span> term, <span>$β_0(x)\equiv 0$</span>. The corresponding coefficient vector is given by <a href="#CamiXon.fdiff_differentiation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Real"><code>fdiff_differentiation_expansion_coeffs(k,x)</code></a>. Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain</p><p class="math-container">\[\frac{df}{dx}[n+x]
=\sum_{p=0}^{k}β_p(x)∇^pf[n]
=\sum_{j=0}^{k}B_j^k(x)f[n-j]
=B^k(x) ⋅ f[n:-1:n-k],\]</p><p>where the <span>$k+1$</span> <em>weights</em></p><p class="math-container">\[ B_j^k(x)=\sum_{p=j}^{k}β_p(x)c_{j}^{p}\]</p><p>are the <span>$k^{th}$</span>-order lagrangian differentiation weights. After changing dummy index to reverse the summation the expansion becomes</p><p class="math-container">\[\frac{df}{dx}[n+x]
=\sum_{j=0}^{k}\bar{B}^k_j(x)f[n-k+j]
=\bar{B}^k(x) ⋅ f[n-k:n].\]</p><p>Functions:</p><p><a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, reg)</code></a> <span>$→ B^k(x) ≡ [B^k_0(x),⋯\ B^k_k(x)]$</span></p><p><a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, rev)</code></a> <span>$→ \bar{B}^k(x) ≡ [B^k_k(x),⋯\ B^k_0(x)]$</span></p><p>where</p><p><a href="#CamiXon.fdiff_differentiation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Real"><code>fdiff_differentiation_expansion_coeffs(o, k)</code></a> <span>$→ β ≡ [β_0(x),⋯\ β_k(x)]$</span>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.fdiff_differentiation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Real" href="#CamiXon.fdiff_differentiation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Real"><code>CamiXon.fdiff_differentiation_expansion_coeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fdiff_differentiation_expansion_coeffs(ξ::T [, k=3 [, notation=bwd]]) where T&lt;:Real</code></pre><p>Finite-difference expansion coefficient vector defining <span>$k^{th}$</span>-order lagrangian <em>differentiation</em> of the tabulated analytic function <span>$f[n]$</span> at offset <span>$ξ$</span> (with respect to index position <span>$n$</span>), which is positive for increasing index and negative for decreasing index.</p><p><strong>Forward difference notation</strong> (<code>notation = fwd</code>)</p><p class="math-container">\[\frac{df}{dξ}[n+ξ]=\sum_{p=0}^kα_p(ξ)Δ^{p}f[n]\]</p><p>Offset convention: <span>$ξ = -σ$</span> with respect to index <span>$n$</span> in tabulated interval <span>$f[n:n+k]$</span></p><p><strong>Backward difference notation</strong> (<code>notation = bwd</code>)</p><p class="math-container">\[\frac{df}{dξ}[n+ξ]=\sum_{p=0}^kβ_p(ξ)∇^{p}f[n]\]</p><p>where <span>$β(ξ) ≡ [β_0(ξ),\ ⋯,\ β_p(ξ)]$</span></p><p>Offset convention: <span>$ξ = σ$</span> with respect to index <span>$n$</span> in tabulated interval <span>$f[n-k:n]$</span></p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">k = 2; ξ = 0
o = fdiff_differentiation_expansion_coeffs(ξ, k); println(o)
 [0.0, 1.0, -1.5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.fdiff_differentiation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}" href="#CamiXon.fdiff_differentiation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.fdiff_differentiation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fdiff_differentiation(f::Vector{T}, v::V; k=3) where {T&lt;:Real, V&lt;:Real}</code></pre><p><span>$k^{th}$</span>-order (default <em>third</em> order) lagrangian <em>differentiation</em> of the analytic function <span>$f$</span>, tabulated in forward order on a uniform grid.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">f = [x^3 for x=-5:5]; println(round.(Int,f))
l = length(f)
f′ = [fdiff_differentiation(f, v) for v=1:l]; println(round.(Int,f′))
  [-125, -64, -27, -8, -1, 0, 1, 8, 27, 64, 125]
  [75, 48, 27, 12, 3, 0, 3, 12, 27, 48, 75]

f′= fdiff_differentiation(f, 1) ; println(&quot;f′(1) = $(f′))
  f′(1) = 75//1

f′= fdiff_differentiation(f, 6.5) ; println(&quot;f′(6.5) = $(f′)&quot;)
    f′(6.5) = 0.75</code></pre><p>For a cubic function the third-order lagrangian differentiation is exact - see Figure below.</p><p><img src="assets/lagrangian_differentiation.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.create_lagrange_differentiation_matrix-Tuple{Int64}" href="#CamiXon.create_lagrange_differentiation_matrix-Tuple{Int64}"><code>CamiXon.create_lagrange_differentiation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_lagrange_differentiation_matrix(k::Int)</code></pre><p>Lagrange differentiation matrix, <span>$m[i,j]=s_{k-j}^k(i)$</span>, for <span>$k^{th}$</span>-order lagrangian differentiation,</p><p class="math-container">\[\frac{dy}{dx}[i]= \sum_{j=0}^{k}m[i,j]y[j],\]</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">k = 3
create_lagrange_differentiation_matrix(k)
 4×4 Matrix{Rational{Int64}}:
  -11//6   3//1  -3//2   1//3
   -1//3  -1//2   1//1  -1//6
    1//6  -1//1   1//2   1//3
   -1//3   3//2  -3//1  11//6</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h3 id="Integration"><a class="docs-heading-anchor" href="#Integration">Integration</a><a id="Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Integration" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.trapezoidal_epw-Tuple{Int64}" href="#CamiXon.trapezoidal_epw-Tuple{Int64}"><code>CamiXon.trapezoidal_epw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trapezoidal_epw(k::Int [; rationalize=false [, devisor=false]])</code></pre><p>Endpoint weights vector <span>$a=[a_1,⋯\ a_k]$</span> of trapeziodal rule optimized for functions of polynomial form,</p><p class="math-container">\[    ∫_0^n f(x) dx = a_1 (f_0+f_n) + ⋯ + a_k (f_{k-1}+f_{n-k+1})
                                                         + (f_k+⋯+f_{n-k}),\]</p><p>where <span>$k$</span> is <em>odd</em>. The rule is exact for polynonials of degree <span>$d=0,\ 1, ⋯,\ k-1$</span>. For <span>$k=1$</span> the rule reduces to the ordinary trapezoidal rule. By default the output is in Float64, optionally the output is rational, with or without specification of the gcd devisor.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">[trapezoidal_epw(k; rationalize=true, devisor=true) for k=1:2:9]
5-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:
  (1, 2, [1])
  (3, 24, [9, 28, 23])
  (5, 1440, [475, 1902, 1104, 1586, 1413])
  (7, 120960, [36799, 176648, 54851, 177984, 89437, 130936, 119585])
  (9, 7257600, [2082753, 11532470, 261166, 16263486, -1020160, 12489922,
                                                     5095890, 7783754, 7200319])</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.trapezoidal_integration-NTuple{4, Any}" href="#CamiXon.trapezoidal_integration-NTuple{4, Any}"><code>CamiXon.trapezoidal_integration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trapezoidal_integration(f, x1, x2, weights)</code></pre><p>Integral of the tabulated function <span>$f=[f_0,⋯\ f_n]$</span> over the <code>domain</code> <span>$x1 ≤ x ≤ x2$</span> using the optimized trapezoidal rule with endpoint correction by the weights vector <code>weights</code>,</p><p class="math-container">\[    ∫_0^n f(x) dx = a_1 (f_0+f_n) + ⋯ + a_k (f_{k-1}+f_{n-k+1})
                                                         + (f_k+⋯+f_{n-k}).\]</p><p>The rule is exact for polynonials of degree <span>$d=0,\ 1,⋯\ k-1$</span>. For <span>$k=1$</span> the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).</p><p><strong>Examples::</strong></p><pre><code class="nohighlight hljs">p = 3
c = [1 for i=0:p]
pol = ImmutablePolynomial(c,:z)
Ipol = integrate(pol)
n = 10

x1=0.0
x2=5.0
x = collect(range(x1, x2, n))
f = pol.(x .-2.5)

w3 = trapezoidal_epw(3)
trapezoidal_integration(f, x1, x2, w3)
 15.416666666666673

Ipol(2.5)-Ipol(-2.5)
 15.41666666666666</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h3 id="Adams-Method"><a class="docs-heading-anchor" href="#Adams-Method">Adams Method</a><a id="Adams-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Method" title="Permalink"></a></h3><h4 id="Adams-Bashford-expansion"><a class="docs-heading-anchor" href="#Adams-Bashford-expansion">Adams-Bashford expansion</a><a id="Adams-Bashford-expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Bashford-expansion" title="Permalink"></a></h4><p>The <em>Adams-Bashford integration step</em> is given by the expansion</p><p class="math-container">\[y[n+1]-y[n] = -\frac{h ∇}{(1-∇)ln(1-∇)}f[n+1]=h (\sum_{p=0}^{\infty}B_p∇^p)f[n+1].\]</p><p>A closed expression for the <em>Adams-Bashford expansion coefficients</em>, <span>$B_k$</span>, is not available. As we already have a finite-difference expansion for the operator <span>$(1-∇)^{-1}$</span>,</p><p class="math-container">\[\frac{1}{1-∇}\equiv\sum_{p=0}^{\infty}∇^p,\]</p><p>we ask for the expansion of</p><p class="math-container">\[-\frac{∇}{ln(1-∇)}
=(1-\frac{1}{2}∇-\frac{1}{24}∇^2-\frac{1}{12}∇^3+⋯)f[n+1]
= (\sum_{p=0}^{\infty}b_p∇^p)f[n+1].\]</p><p>This is known as the <em>Adams-Moulton expansion</em>. Its coefficients are calculated numerically by the function <code>fdiff_expansion_adams_moulton_coeffs(k)</code>. The <em>Adams-Bashford expansion</em> is obtained as the polynomial product of the two expansions,</p><p class="math-container">\[(\sum_{p=0}^{\infty}B_p∇^p)f[n+1]
=(\sum_{p=0}^{\infty}∇^p)(\sum_{p=0}^{\infty}b_p∇^p)f[n+1]
=\ ( 1 + \frac{1}{2}∇ + \frac{5}{12}∇^2 + ⋯)f[n+1].\]</p><p>The coefficients <span>$B_p$</span> are calculated numerically with the function <code>fdiff_expansion_adams_bashford_coeffs(k)</code>. Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain (after changing dummy index bring the summation in forward order)</p><p class="math-container">\[\sum_{p=0}^{k}B_p∇^pf[n]
=\sum_{p=0}^{k}B_p\sum_{j=0}^{p} c_j^if[n-j]
= \sum_{j=0}^{k}A_j^k(x)f[n-j]
= \sum_{j=0}^{k}A_{k-j}^k(x)f[n-k+j],\]</p><p>where the <span>$A_j^k(x)= \sum_{p=j}^{k} B_pc_j^p$</span> are the <span>$(k+1)$</span>-point <em>Adams-Bashford integration weights</em>.</p><p>Function:</p><p><code>β</code> = <a href="#CamiXon.fdiff_adams_bashford_expansion_coeffs-Tuple{Int64}"><code>fdiff_adams_bashford_expansion_coeffs(k)</code></a>  <span>$→ [B_k^k(x),⋯\ B_0^k(x)]$</span></p><p><code>adams_bashford_weights</code> = <a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, rev)</code></a>  <span>$→ [A_k^k(x),⋯\ A_0^k(x)]$</span></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.fdiff_adams_bashford_expansion_coeffs-Tuple{Int64}" href="#CamiXon.fdiff_adams_bashford_expansion_coeffs-Tuple{Int64}"><code>CamiXon.fdiff_adams_bashford_expansion_coeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fdiff_adams_bashford_expansion_coeffs(k [; T=Int])</code></pre><p><span>$(k+1)$</span>-point Adams-Bashford expansion coefficients <span>$B_p$</span>.</p><p class="math-container">\[-\frac{∇}{(1-∇)ln(1-∇)}=\sum_{p=0}^{\infty}B_p∇^p=1+\ \frac{1}{2}∇+\ \frac{5}{12}∇^2+\ ⋯.\]</p><p>The weights are stored in <em>forward</em> order: <span>$[B_0^k,⋯\ B_k^k]$</span> - order of use in summation.</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">k = 5
o = fdiff_adams_bashford_expansion_coeffs(k); println(o)
 Rational{Int64}[1//1, 1//2, 5//12, 3//8, 251//720, 95//288]</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h3 id="Adams-Moulton-expansion"><a class="docs-heading-anchor" href="#Adams-Moulton-expansion">Adams-Moulton expansion</a><a id="Adams-Moulton-expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Moulton-expansion" title="Permalink"></a></h3><p>The <em>Adams-Moulton integration</em> step is given by the expansion</p><p class="math-container">\[y[n+1]-y[n]
= -\frac{∇}{ln(1-∇)}f[n+1]
= ( 1 - \frac{1}{2}∇ - \frac{1}{12}∇^2 - \frac{1}{24}∇^3 +⋯)f[n+1].\]</p><p>For the evaluation of the integration step we limit the summation to <span>$k+1$</span> terms (order <span>$k$</span>),</p><p class="math-container">\[y[n+1]-y[n]= (\sum_{p=0}^{k}b_p∇^p)f[n+1]+⋯.\]</p><p>where <span>$b_0,⋯\ b_k$</span> are the <em>Adams-Moulton expansion coefficients</em>, rational numbers generated numerically by the function <a href="#CamiXon.fdiff_adams_moulton_expansion_coeff-Tuple{T} where T&lt;:Integer"><code>fdiff_adams_moulton_expansion_coeff(k)</code></a>. Extracting the greatest common denominator, <span>$1/D$</span>, the step becomes</p><p class="math-container">\[y[n+1]-y[n]= \frac{1}{D}(\sum_{p=0}^{k}b_p^{\prime}∇^p)f[n+1]+⋯,\]</p><p>where <span>$b_0^{\prime},⋯\ b_k^{\prime}$</span> are integers and <span>$b_p=b_p^{\prime}/D$</span>. In practice the expansion is restricted to <span>$k&lt;18$</span> (as limited by integer overflow). Note that this limit is much higher than values used in calculations (typically up to <span>$k = 10$</span>). Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain (after changing dummy index bring the summation in forward order)</p><p class="math-container">\[\sum_{p=0}^{k}b_p∇^pf[n]
=\sum_{p=0}^{k}b_p\sum_{j=0}^{p} c_j^if[n-j]
= \sum_{j=0}^{k}a_j^k(x)f[n-j]
= \sum_{j=0}^{k}a_{k-j}^k(x)f[n-k+j],\]</p><p>where the <span>$a_j^k(x)= \sum_{p=j}^{k} b_pc_j^p$</span> are the <span>$(k+1)$</span>-point <em>Adams-Moulton integration weights</em>.</p><p>Functions:</p><p><code>β</code> = <a href="#CamiXon.fdiff_adams_moulton_expansion_coeff-Tuple{T} where T&lt;:Integer"><code>fdiff_adams_moulton_expansion_coeff(k)</code></a> <span>$→ [b_0,⋯\ b_k]$</span></p><p><code>adams_moulton_weights</code> = <a href="#CamiXon.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, rev)</code></a> <span>$→ [a_k^k,⋯\ a_0^k]$</span>.</p><p><code>adams_moulton_weights</code> = <a href="#CamiXon.create_adams_moulton_weights-Tuple{Int64}"><code>create_adams_moulton_weights(k)</code></a> <span>$→ [a_k^k,⋯\ a_0^k]$</span></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.fdiff_adams_moulton_expansion_coeff-Tuple{T} where T&lt;:Integer" href="#CamiXon.fdiff_adams_moulton_expansion_coeff-Tuple{T} where T&lt;:Integer"><code>CamiXon.fdiff_adams_moulton_expansion_coeff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fdiff_adams_moulton_expansion_coeff(n::T; msg=true) where {T&lt;:Integer}
fdiff_adams_moulton_expansion_coeffs(n::T; msg=true) where {T&lt;:Integer}</code></pre><p>Finite difference expansion coefficient vector <span>$β ≡ [β_0(x),\ ⋯,\ β_p(x)]$</span> defining <span>$k^{th}$</span>-order Adams-Moulton expansion,</p><p class="math-container">\[-\frac{∇}{ln(1-∇)}
= \sum_{p=0}^{\infty}β_p∇^p
= 1 - \frac{1}{2}∇ - \frac{1}{12}∇^2 - \frac{1}{24}∇^3 +⋯.\]</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; k = 5;
julia&gt; β = fdiff_adams_moulton_expansion_coeffs(k); println(β)
Rational{Int64}[1//1, -1//2, -1//12, -1//24, -19//720, -3//160]

julia&gt; D = denominator(gcd(β))
1440

julia&gt; o = convert(Vector{Int},(β .* D)); println(o)
[1440, -720, -120, -60, -38, -27]

julia&gt; k=20;
julia&gt; fdiff_adams_moulton_expansion_coeff(k)
Integer-overflow protection: output converted to BigInt
-12365722323469980029//4817145976189747200000</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.create_adams_moulton_weights-Tuple{Int64}" href="#CamiXon.create_adams_moulton_weights-Tuple{Int64}"><code>CamiXon.create_adams_moulton_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_adams_moulton_weights(k::Int [; rationalize=false [, devisor=false [, T=Int]]])</code></pre><p><span>$k^{th}$</span>-order Adams-Moulton weights vector,</p><p class="math-container">\[y[n+1] = y[n] + \frac{1}{D}\sum_{j=0}^{k}a^k[j]f[n+1-k+j]\]</p><p>The weights are stored in the vector <span>$a^k \equiv[a_k^k/D,⋯\ a_0^k/D]$</span> under the convention <span>$a^k[j] \equiv a_{k-j}^k/D$</span>, where <span>$a_j^k$</span> are the Adams-Moulton weight coefficients and <span>$D$</span> the corresponding Adams-Moulton divisor. By default the output is in Float64, optionally the output is rational,  with or without specification of the gcd devisor.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">[create_adams_moulton_weights(k; rationalize=true, devisor=true, T=Int) for k=1:8]
8-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:
 (1, 2, [1, 1])
 (2, 12, [-1, 8, 5])
 (3, 24, [1, -5, 19, 9])
 (4, 720, [-19, 106, -264, 646, 251])
 (5, 1440, [27, -173, 482, -798, 1427, 475])
 (6, 60480, [-863, 6312, -20211, 37504, -46461, 65112, 19087])
 (7, 120960, [1375, -11351, 41499, -88547, 123133, -121797, 139849, 36799])
 (8, 3628800, [-33953, 312874, -1291214, 3146338, -5033120, 5595358, -4604594, 4467094, 1070017])</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h2 id="Strings"><a class="docs-heading-anchor" href="#Strings">Strings</a><a id="Strings-1"></a><a class="docs-heading-anchor-permalink" href="#Strings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.sup-Tuple{T} where T&lt;:Real" href="#CamiXon.sup-Tuple{T} where T&lt;:Real"><code>CamiXon.sup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sup(i::T) where T&lt;:Real</code></pre><p>Superscript notation for integers and rational numbers</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">sup(3) * &#39;P&#39;
 &quot;³P&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.sub-Tuple{T} where T&lt;:Real" href="#CamiXon.sub-Tuple{T} where T&lt;:Real"><code>CamiXon.sub</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sub(i::T) where T&lt;:Real
sub(str::String)</code></pre><p>Subscript notation for integers, rational numbers and a <em>subset</em> of lowercase characters (&#39;a&#39;,&#39;e&#39;,&#39;h&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;,&#39;n&#39;,&#39;o&#39;,&#39;p&#39;,&#39;r&#39;,&#39;s&#39;,&#39;t&#39;,&#39;x&#39;)</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">&#39;D&#39; * sub(5//2)
 &quot;D₅⸝₂&quot;

&quot;m&quot; * sub(&quot;e&quot;)
 &quot;mₑ&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.frac-Tuple{Rational{Int64}}" href="#CamiXon.frac-Tuple{Rational{Int64}}"><code>CamiXon.frac</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">frac(i)</code></pre><p>Fraction notation for rational numbers</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">frac(-5//2)
 &quot;-⁵/₂&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.strRational-Tuple{T} where T&lt;:Union{Int64, BigInt, Rational}" href="#CamiXon.strRational-Tuple{T} where T&lt;:Union{Int64, BigInt, Rational}"><code>CamiXon.strRational</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">strRational(i)</code></pre><p>Fraction notation for rational numbers and integers</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">strRational(-5//2)
 &quot;-5/2&quot;

 strRational(-5//2)
  &quot;-5&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h2 id="Dicts"><a class="docs-heading-anchor" href="#Dicts">Dicts</a><a id="Dicts-1"></a><a class="docs-heading-anchor-permalink" href="#Dicts" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.dictAntoineCoefficients" href="#CamiXon.dictAntoineCoefficients"><code>CamiXon.dictAntoineCoefficients</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">dictAntoineCoefficients</code></pre><p>Antoine coefficients [A,B,C,D] for temperature ranges below and above the melting points from <a href="#CamiXon.dictMeltingPoints"><code>dictMeltingPoints</code></a>. These coefficients are used  in the Antoine equation to calculate the saturated vapor pressure <em>p</em> (in Pa)  at temperature `<em>T</em> (in K),</p><p class="math-container">\[\mathrm{log_{e}}p=A+B/T+C\mathrm{log_{10}}T+D\cdot T/1000.\]</p><p>Currently, only the coefficients for the metalic elements are implemented - see C. B. Alcock, V. P. Itkin and M. K. Horrigan, Canadian Metallurgical Quarterly, 23, 309 (1984).</p><p>Note that the melting point is taken to be pressure independent.</p><pre><code class="nohighlight hljs">julia&gt; dictAntoineCoefficients
Dict{Int64, Tuple{Any, Any, Tuple{Any, Any, Any}}} with 102 entries:
  5  =&gt; (nothing, nothing, (empty, 2349.0, empty))
  56 =&gt; ([40.0897, -22312.0, -5.27062, 0.0], [20.7526, -18796.0, 0.0, 0.0], (298.0, 1000.0, 1200.0))
  35 =&gt; (nothing, nothing, (empty, 265.8, empty))
  55 =&gt; ([22.3736, -9208.04, 0.0, 0.0], [21.1164, -8818.9, 0.0, 0.0], (298.0, 301.7, 550.0))
  60 =&gt; ([32.2402, -39751.8, -2.19183, 0.0], [22.8364, -36436.1, 0.0, 0.0], (298.0, 1297.0, 2000.0))
  30 =&gt; ([25.5765, -15602.3, 0.0, 0.0], [23.9094, -14474.0, 0.0, 0.0], (298.0, 692.68, 750.0))
  32 =&gt; (nothing, nothing, (empty, 1211.4, empty))
  ⋮  =&gt; ⋮</code></pre><p><strong>Examples:</strong></p><p>To calculate the saturated vapor pressure of Li (in Pa) at T=623 K we use the Antoine equation implemented in thefunction <a href="#CamiXon.svp-Tuple{Int64, Real}"><code>svp</code></a>.</p><pre><code class="nohighlight hljs">julia&gt; svp(55, 400)
0.39420306801845933

julia&gt; svp(&quot;Cs&quot;, 400)
0.39420306801845933</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.dictAtomicNumbers" href="#CamiXon.dictAtomicNumbers"><code>CamiXon.dictAtomicNumbers</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">dictAtomicNumbers</code></pre><pre><code class="nohighlight hljs">julia&gt; dictAtomicNumbers
Dict{String, Int64} with 102 entries: 
  &quot;Pd&quot; =&gt; 46
  &quot;Si&quot; =&gt; 14
  &quot;C&quot;  =&gt; 6
  &quot;P&quot;  =&gt; 15
  &quot;Nb&quot; =&gt; 41
    ⋮  =&gt;  ⋮</code></pre><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; Z = get(dictAtomicNumbers, &quot;Rb&quot;, nothing)
37

julia&gt; listElement(Z; fmt=Info)
Element: rubidium
symbol: Rb
atomic number: Z = 37
atomic weight (relative atomic mass): 85.468</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.dictBigConversion" href="#CamiXon.dictBigConversion"><code>CamiXon.dictBigConversion</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">dictBigConversion</code></pre><p>Dictionary for conversion from Int-based types to BigInt-based types</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; dictBigConversion
Dict{DataType, DataType} with 12 entries:
  Vector{Rational{Int64}}         =&gt; Vector{Rational{BigInt}}
  Int64                           =&gt; BigInt
  Vector{Float64}                 =&gt; Vector{BigFloat}
  ComplexF64                      =&gt; Complex{BigFloat}
  Vector{Vector{ComplexF64}}      =&gt; Vector{Vector{Complex{BigFloat}}}
  Vector{Int64}                   =&gt; Vector{BigInt}
  Vector{Vector{Int64}}           =&gt; Vector{Vector{BigInt}}
  Vector{Vector{Float64}}         =&gt; Vector{Vector{BigFloat}}
  Vector{Vector{Rational{Int64}}} =&gt; Vector{Vector{Rational{Int64}}}
  Float64                         =&gt; BigFloat
  Rational{Int64}                 =&gt; Rational{BigInt}
  Vector{ComplexF64}              =&gt; Vector{Complex{BigFloat}}</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.dictElements" href="#CamiXon.dictElements"><code>CamiXon.dictElements</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">dictElements</code></pre><p>Standard atomic weights of the elements 2021 - see IUPAC Technical Report</p><pre><code class="nohighlight hljs">julia&gt; dictElements
Dict{Int64, Tuple{String, String, Any}} with 102 entries:
  5  =&gt; (&quot;boron&quot;, &quot;B&quot;, 10.81)
  56 =&gt; (&quot;barium&quot;, &quot;Ba&quot;, 137.33)
  35 =&gt; (&quot;bromine&quot;, &quot;Br&quot;, 79.904)
  55 =&gt; (&quot;caesium&quot;, &quot;Cs&quot;, 132.91)
  60 =&gt; (&quot;neodymium&quot;, &quot;Nd&quot;, 144.24)
  30 =&gt; (&quot;zinc&quot;, &quot;Zn&quot;, 65.38)
   ⋮ =&gt;  ⋮</code></pre><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; get(dictElements, 37, nothing)
(&quot;rubidium&quot;, &quot;Rb&quot;, 85.468)

julia&gt; listElement(&quot;Rb&quot;, fmt=Info)
Element: rubidium
  symbol: Rb
  atomic number: Z = 37
  atomic weight (relative atomic mass): 85.468</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.dictIsotopes" href="#CamiXon.dictIsotopes"><code>CamiXon.dictIsotopes</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">dictIsotopes</code></pre><p>Sources: AME2020, LINDC(NDS)-0794 and INDC(NDS)-0833</p><pre><code class="nohighlight hljs">julia&gt; dictIsotopes
Dict{Tuple{Int64, Int64}, Tuple{String, String, Int64, Int64, Int64, Float64, Float64, Real, Int64, Float64, Float64, Any, Any}} with 341 entries:
  (71, 175) =&gt; (&quot;¹⁷⁵Lu&quot;, &quot;lutetium&quot;, 71, 175, 104, 5.37, 174.941, 7//2, 1, 1.0e…
  (40, 92)  =&gt; (&quot;⁹²Zr&quot;, &quot;zirconium&quot;, 40, 92, 52, 4.3057, 91.905, 0, 1, 1.0e100,…
  (48, 111) =&gt; (&quot;¹¹¹Cd&quot;, &quot;cadmium&quot;, 48, 111, 63, 4.5845, 110.904, 1//2, 1, 1.0e…
  (72, 176) =&gt; (&quot;¹⁷⁶Hf&quot;, &quot;hafnium&quot;, 72, 176, 104, 5.3286, 175.941, 0, 1, 1.0e10…
  (30, 68)  =&gt; (&quot;⁶⁸Zn&quot;, &quot;zinc&quot;, 30, 68, 38, 3.9658, 67.9248, 0, 1, 1.0e100, 0.0…
  (76, 184) =&gt; (&quot;¹⁸⁴Os&quot;, &quot;osmium&quot;, 76, 184, 108, 5.3823, 183.952, 0, 1, 5.6e13,…
  (54, 129) =&gt; (&quot;¹²⁹Xe&quot;, &quot;xenon&quot;, 54, 129, 75, 4.7775, 128.905, 1//2, 1, 1.0e10…
      ⋮     =&gt;                                ⋮</code></pre><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; get(dictIsotopes, (37,87), nothing)
(&quot;⁸⁷Rb&quot;, &quot;rubidium&quot;, 37, 87, 50, 4.1989, 86.90918053, 3//2, -1, 4.97e10, 2.75129, 0.1335, 27.83)

julia&gt; listIsotope(37, 87, fmt=Info)
Isotope: rubidium-87
  symbol: ⁸⁷Rb
  element: rubidium
  atomic number: Z = 37
  atomic mass number: A = 87
  neutron number: N = 50
  rms nuclear charge radius: R = 4.1989 fm
  atomic mass: M = 86.90918053 amu
  nuclear spin: I = 3/2 ħ
  parity of nuclear state: π = odd
  nuclear magnetic dipole moment: μI = 2.75129 μN
  nuclear electric quadrupole moment: Q = 0.1335 barn
  relative abundance: RA = 27.83%
  lifetime: 4.97e10 years</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiXon.dictMeltingPoints" href="#CamiXon.dictMeltingPoints"><code>CamiXon.dictMeltingPoints</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">dictMeltingPoints</code></pre><p>Melting points of the elements at standard pressure (1atm) - see Wikipedia</p><pre><code class="nohighlight hljs">julia&gt; dictMeltingPoints
Dict{Int64, Union{Nothing, Real}} with 102 entries:
  5  =&gt; 2349   
  56 =&gt; 1000   
  35 =&gt; 265.8  
  55 =&gt; 301.7  
  60 =&gt; 1297   
  30 =&gt; 692.68 
  32 =&gt; 1211.4 
  6  =&gt; nothing
  67 =&gt; 1734   
  ⋮  =&gt; ⋮</code></pre><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; get(dictMeltingPoints, 3, nothing)
453.65

julia&gt; melting_point(&quot;Li&quot;)
453.65</code></pre></div><a class="docs-sourcelink" target="_blank" href="github.com/walra356/CamiXon.jl.git">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#CamiXon.dictAntoineCoefficients"><code>CamiXon.dictAntoineCoefficients</code></a></li><li><a href="#CamiXon.dictAtomicNumbers"><code>CamiXon.dictAtomicNumbers</code></a></li><li><a href="#CamiXon.dictBigConversion"><code>CamiXon.dictBigConversion</code></a></li><li><a href="#CamiXon.dictElements"><code>CamiXon.dictElements</code></a></li><li><a href="#CamiXon.dictIsotopes"><code>CamiXon.dictIsotopes</code></a></li><li><a href="#CamiXon.dictMeltingPoints"><code>CamiXon.dictMeltingPoints</code></a></li><li><a href="#CamiXon.Adams"><code>CamiXon.Adams</code></a></li><li><a href="#CamiXon.Atom"><code>CamiXon.Atom</code></a></li><li><a href="#CamiXon.Codata"><code>CamiXon.Codata</code></a></li><li><a href="#CamiXon.Def"><code>CamiXon.Def</code></a></li><li><a href="#CamiXon.Element"><code>CamiXon.Element</code></a></li><li><a href="#CamiXon.Grid"><code>CamiXon.Grid</code></a></li><li><a href="#CamiXon.Isotope"><code>CamiXon.Isotope</code></a></li><li><a href="#CamiXon.NamedValue"><code>CamiXon.NamedValue</code></a></li><li><a href="#CamiXon.Orbit"><code>CamiXon.Orbit</code></a></li><li><a href="#CamiXon.Pos"><code>CamiXon.Pos</code></a></li><li><a href="#CamiXon.Spinorbit"><code>CamiXon.Spinorbit</code></a></li><li><a href="#CamiXon.Term"><code>CamiXon.Term</code></a></li><li><a href="#CamiXon.Value"><code>CamiXon.Value</code></a></li><li><a href="#CamiXon.CGC-NTuple{6, Real}"><code>CamiXon.CGC</code></a></li><li><a href="#CamiXon.INSCH-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.INSCH</code></a></li><li><a href="#CamiXon.OUTSCH-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Array{Matrix{T}, 1}}} where T&lt;:Real"><code>CamiXon.OUTSCH</code></a></li><li><a href="#CamiXon.RH1s-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U&lt;:Real, T&lt;:Real}"><code>CamiXon.RH1s</code></a></li><li><a href="#CamiXon.RH2p-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U&lt;:Real, T&lt;:Real}"><code>CamiXon.RH2p</code></a></li><li><a href="#CamiXon.RH2s-Union{Tuple{T}, Tuple{U}, Tuple{U, T}} where {U&lt;:Real, T&lt;:Real}"><code>CamiXon.RH2s</code></a></li><li><a href="#CamiXon.UF-Union{Tuple{V}, Tuple{T}, Tuple{Int64, Vector{T}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.UF</code></a></li><li><a href="#CamiXon.UG-Union{Tuple{V}, Tuple{T}, Tuple{Int64, Vector{T}, Vector{T}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.UG</code></a></li><li><a href="#CamiXon.a_direct-NTuple{5, Int64}"><code>CamiXon.a_direct</code></a></li><li><a href="#CamiXon.adams_moulton_inward-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_inward</code></a></li><li><a href="#CamiXon.adams_moulton_iterate-Union{Tuple{T}, Tuple{NTuple{4, T}, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_iterate</code></a></li><li><a href="#CamiXon.adams_moulton_master-Tuple{Any, Any, Any}"><code>CamiXon.adams_moulton_master</code></a></li><li><a href="#CamiXon.adams_moulton_normalized-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_normalized</code></a></li><li><a href="#CamiXon.adams_moulton_outward-Union{Tuple{T}, Tuple{Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_outward</code></a></li><li><a href="#CamiXon.adams_moulton_patch-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_patch</code></a></li><li><a href="#CamiXon.adams_moulton_prepare-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams{T}}} where T&lt;:Real"><code>CamiXon.adams_moulton_prepare</code></a></li><li><a href="#CamiXon.adams_moulton_solve-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, Adams}} where T&lt;:Real"><code>CamiXon.adams_moulton_solve</code></a></li><li><a href="#CamiXon.autoGrid-Tuple{Atom, Orbit, Type}"><code>CamiXon.autoGrid</code></a></li><li><a href="#CamiXon.autoNtot-Tuple{Orbit}"><code>CamiXon.autoNtot</code></a></li><li><a href="#CamiXon.autoPrecision-Union{Tuple{T}, Tuple{T, Orbit}} where T&lt;:Real"><code>CamiXon.autoPrecision</code></a></li><li><a href="#CamiXon.autoRmax-Tuple{Atom, Orbit}"><code>CamiXon.autoRmax</code></a></li><li><a href="#CamiXon.autoSteps-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiXon.autoSteps</code></a></li><li><a href="#CamiXon.b_exchange-NTuple{5, Int64}"><code>CamiXon.b_exchange</code></a></li><li><a href="#CamiXon.bigconvert-Tuple{Any}"><code>CamiXon.bigconvert</code></a></li><li><a href="#CamiXon.bohrformula-Tuple{Int64, Int64}"><code>CamiXon.bohrformula</code></a></li><li><a href="#CamiXon.calibrationReport-Tuple{Any, Any, Codata}"><code>CamiXon.calibrationReport</code></a></li><li><a href="#CamiXon.castAdams-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.castAdams</code></a></li><li><a href="#CamiXon.castAtom-Tuple{}"><code>CamiXon.castAtom</code></a></li><li><a href="#CamiXon.castCodata-Tuple{Int64}"><code>CamiXon.castCodata</code></a></li><li><a href="#CamiXon.castDef-Union{Tuple{T}, Tuple{Grid{T}, Atom, Orbit, Codata}} where T&lt;:Real"><code>CamiXon.castDef</code></a></li><li><a href="#CamiXon.castElement-Tuple{}"><code>CamiXon.castElement</code></a></li><li><a href="#CamiXon.castGrid-Tuple{Int64, Int64, Type}"><code>CamiXon.castGrid</code></a></li><li><a href="#CamiXon.castIsotope-Tuple{}"><code>CamiXon.castIsotope</code></a></li><li><a href="#CamiXon.castNamedValue-Tuple{Value}"><code>CamiXon.castNamedValue</code></a></li><li><a href="#CamiXon.castOrbit-Tuple{}"><code>CamiXon.castOrbit</code></a></li><li><a href="#CamiXon.castSpinorbit-Tuple{}"><code>CamiXon.castSpinorbit</code></a></li><li><a href="#CamiXon.conditionalType-Union{Tuple{T}, Tuple{T, Int64}} where T&lt;:Integer"><code>CamiXon.conditionalType</code></a></li><li><a href="#CamiXon.convertUnit-Tuple{Any, Any}"><code>CamiXon.convertUnit</code></a></li><li><a href="#CamiXon.count_nodes-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.count_nodes</code></a></li><li><a href="#CamiXon.createTerm-Tuple{Int64}"><code>CamiXon.createTerm</code></a></li><li><a href="#CamiXon.create_adams_moulton_weights-Tuple{Int64}"><code>CamiXon.create_adams_moulton_weights</code></a></li><li><a href="#CamiXon.create_lagrange_differentiation_matrix-Tuple{Int64}"><code>CamiXon.create_lagrange_differentiation_matrix</code></a></li><li><a href="#CamiXon.demo_hydrogen-Tuple{}"><code>CamiXon.demo_hydrogen</code></a></li><li><a href="#CamiXon.edges"><code>CamiXon.edges</code></a></li><li><a href="#CamiXon.fdiff_adams_bashford_expansion_coeffs-Tuple{Int64}"><code>CamiXon.fdiff_adams_bashford_expansion_coeffs</code></a></li><li><a href="#CamiXon.fdiff_adams_moulton_expansion_coeff-Tuple{T} where T&lt;:Integer"><code>CamiXon.fdiff_adams_moulton_expansion_coeff</code></a></li><li><a href="#CamiXon.fdiff_differentiation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.fdiff_differentiation</code></a></li><li><a href="#CamiXon.fdiff_differentiation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Real"><code>CamiXon.fdiff_differentiation_expansion_coeffs</code></a></li><li><a href="#CamiXon.fdiff_expansion"><code>CamiXon.fdiff_expansion</code></a></li><li><a href="#CamiXon.fdiff_expansion_weights"><code>CamiXon.fdiff_expansion_weights</code></a></li><li><a href="#CamiXon.fdiff_interpolation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.fdiff_interpolation</code></a></li><li><a href="#CamiXon.fdiff_interpolation_expansion_coeffs-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>CamiXon.fdiff_interpolation_expansion_coeffs</code></a></li><li><a href="#CamiXon.fdiff_weight-Tuple{Int64, Int64}"><code>CamiXon.fdiff_weight</code></a></li><li><a href="#CamiXon.findIndex-Union{Tuple{T}, Tuple{T, Grid{T}}} where T&lt;:Number"><code>CamiXon.findIndex</code></a></li><li><a href="#CamiXon.find_all-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_all</code></a></li><li><a href="#CamiXon.find_first-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_first</code></a></li><li><a href="#CamiXon.find_last-Union{Tuple{T}, Tuple{Union{AbstractVector{T}, String}, Vararg{T}}} where T"><code>CamiXon.find_last</code></a></li><li><a href="#CamiXon.frac-Tuple{Rational{Int64}}"><code>CamiXon.frac</code></a></li><li><a href="#CamiXon.get_Na-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Na</code></a></li><li><a href="#CamiXon.get_Nb-Union{Tuple{T}, Tuple{Array{Complex{T}, 1}, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nb</code></a></li><li><a href="#CamiXon.get_Nlctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nlctp</code></a></li><li><a href="#CamiXon.get_Nmin-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.get_Nmin</code></a></li><li><a href="#CamiXon.get_Nuctp-Union{Tuple{T}, Tuple{T, Def{T}}} where T&lt;:Real"><code>CamiXon.get_Nuctp</code></a></li><li><a href="#CamiXon.grid_differentiation-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T&lt;:Real"><code>CamiXon.grid_differentiation</code></a></li><li><a href="#CamiXon.grid_integration-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, Int64, Int64, Grid{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.grid_integration</code></a></li><li><a href="#CamiXon.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiXon.gridfunction</code></a></li><li><a href="#CamiXon.gridname-Tuple{Int64}"><code>CamiXon.gridname</code></a></li><li><a href="#CamiXon.hydrogenic_reduced_wavefunction-Tuple{Any, Orbit, Grid}"><code>CamiXon.hydrogenic_reduced_wavefunction</code></a></li><li><a href="#CamiXon.initE-Union{Tuple{Def{T}}, Tuple{T}} where T&lt;:Real"><code>CamiXon.initE</code></a></li><li><a href="#CamiXon.isforward-Tuple{Any}"><code>CamiXon.isforward</code></a></li><li><a href="#CamiXon.isregular-Tuple{Any}"><code>CamiXon.isregular</code></a></li><li><a href="#CamiXon.latent_heat_vaporization-Tuple{Int64, Real}"><code>CamiXon.latent_heat_vaporization</code></a></li><li><a href="#CamiXon.latexIsotopeTable-Tuple{Int64, Int64}"><code>CamiXon.latexIsotopeTable</code></a></li><li><a href="#CamiXon.lc_eltype-Tuple{Any}"><code>CamiXon.lc_eltype</code></a></li><li><a href="#CamiXon.lc_primitivetype-Tuple{Any}"><code>CamiXon.lc_primitivetype</code></a></li><li><a href="#CamiXon.listAtom-Tuple{Int64, Int64, Int64}"><code>CamiXon.listAtom</code></a></li><li><a href="#CamiXon.listAtoms-Tuple{Int64, Int64, Int64}"><code>CamiXon.listAtoms</code></a></li><li><a href="#CamiXon.listCodata-Tuple{Codata}"><code>CamiXon.listCodata</code></a></li><li><a href="#CamiXon.listElement-Tuple{Int64}"><code>CamiXon.listElement</code></a></li><li><a href="#CamiXon.listElements-Tuple{Int64, Int64}"><code>CamiXon.listElements</code></a></li><li><a href="#CamiXon.listIsotope-Tuple{Int64, Int64}"><code>CamiXon.listIsotope</code></a></li><li><a href="#CamiXon.listIsotopes-Tuple{Int64, Int64}"><code>CamiXon.listIsotopes</code></a></li><li><a href="#CamiXon.matG-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.matG</code></a></li><li><a href="#CamiXon.matMinv-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}, T}} where T&lt;:Real"><code>CamiXon.matMinv</code></a></li><li><a href="#CamiXon.matσ-Union{Tuple{T}, Tuple{T, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.matσ</code></a></li><li><a href="#CamiXon.melting_point-Tuple{Int64}"><code>CamiXon.melting_point</code></a></li><li><a href="#CamiXon.primitivetype-Tuple{Type}"><code>CamiXon.primitivetype</code></a></li><li><a href="#CamiXon.reduce_wavefunction-Union{Tuple{V}, Tuple{T}, Tuple{Array{Complex{T}, 1}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.reduce_wavefunction</code></a></li><li><a href="#CamiXon.restore_wavefunction-Union{Tuple{V}, Tuple{T}, Tuple{Array{Complex{T}, 1}, Grid{V}}} where {T&lt;:Real, V&lt;:Real}"><code>CamiXon.restore_wavefunction</code></a></li><li><a href="#CamiXon.select125-Tuple{Any}"><code>CamiXon.select125</code></a></li><li><a href="#CamiXon.step125-Tuple{Real}"><code>CamiXon.step125</code></a></li><li><a href="#CamiXon.stepcenters-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.stepcenters</code></a></li><li><a href="#CamiXon.stepedges-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.stepedges</code></a></li><li><a href="#CamiXon.steps-Tuple{Vector{T} where T&lt;:Real}"><code>CamiXon.steps</code></a></li><li><a href="#CamiXon.strRational-Tuple{T} where T&lt;:Union{Int64, BigInt, Rational}"><code>CamiXon.strRational</code></a></li><li><a href="#CamiXon.strValue-Tuple{Value}"><code>CamiXon.strValue</code></a></li><li><a href="#CamiXon.sub-Tuple{T} where T&lt;:Real"><code>CamiXon.sub</code></a></li><li><a href="#CamiXon.sup-Tuple{T} where T&lt;:Real"><code>CamiXon.sup</code></a></li><li><a href="#CamiXon.svp-Tuple{Int64, Real}"><code>CamiXon.svp</code></a></li><li><a href="#CamiXon.threeJsymbol-NTuple{6, Real}"><code>CamiXon.threeJsymbol</code></a></li><li><a href="#CamiXon.trapezoidal_epw-Tuple{Int64}"><code>CamiXon.trapezoidal_epw</code></a></li><li><a href="#CamiXon.trapezoidal_integration-NTuple{4, Any}"><code>CamiXon.trapezoidal_integration</code></a></li><li><a href="#CamiXon.updateAdams!-Union{Tuple{T}, Tuple{Adams{T}, Any, Grid{T}, Def{T}}} where T&lt;:Real"><code>CamiXon.updateAdams!</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Monday 19 August 2024 01:29">Monday 19 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
